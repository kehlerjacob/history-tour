<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Historic Landmark Map with Real-Time GeoSearch and Navigation</title>
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>

    <!-- Leaflet Polyline Decoders/Encoders - required for OSRM routes -->
    <script src="https://unpkg.com/@mapbox/polyline@1.0.0/src/polyline.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fc;
        }

        .leaflet-container {
            font-family: 'Inter', sans-serif;
            position: relative !important;
            z-index: 1 !important;
        }

        #map {
            position: relative !important;
            z-index: 1 !important;
        }

        .leaflet-default-icon-path {
            /* Standard marker path, kept for fallback */
            background-image: url('https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png');
        }

        input[type=range] {
            -webkit-appearance: none;
            background: transparent;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #a5b4fc;
            border-radius: 2px;
        }

        /* User Marker Arrow (The blue circle container) */
        .user-arrow-marker {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px !important;
            height: 40px !important;
            margin-left: -20px !important;
            margin-top: -20px !important;
            position: relative;
            /* Needed for absolute positioning of the triangle */
            transition: transform 0.3s ease-out;
            /* Smooth marker transition */
        }

        /* The Rotating White Triangle Indicator */
        #userDirectionArrow {
            position: absolute;
            /* Pivot point: slightly below the geometric center to place the tip visually correct */
            transform-origin: 50% 75%;

            /* Create the triangle shape using CSS borders */
            width: 0;
            height: 0;
            border-style: solid;
            border-width: 0 6px 14px 6px;
            /* 14px height, 12px base width */
            border-color: transparent transparent #ffffff transparent;
            /* White tip pointing up */

            /* Adjust position to center the pivot point */
            margin-top: -10px;
            /* REDUCED TRANSITION TIME FOR SMOOTH COMPASS MOVEMENT */
            transition: transform 0.05s linear;
        }

        /* Message Box for custom alerts */
        #messageBox {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 5000;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        #messageBox.visible {
            opacity: 1;
            pointer-events: auto;
        }

        /* HIDE LEAFLET ZOOM CONTROLS FOR A CLEANER UI */
        .leaflet-control-zoom {
            display: none !important;
        }

        /* Icon styling for navigation instructions */
        .nav-icon {
            display: inline-block;
            width: 1.5rem;
            height: 1.5rem;
            margin-right: 0.5rem;
            vertical-align: middle;
        }
    </style>
</head>

<body class="flex flex-col h-screen overflow-hidden">

    <!-- Message Box (Custom Alert) -->
    <div id="messageBox" class="p-6 bg-white rounded-xl shadow-2xl max-w-sm w-full">
        <h3 id="messageTitle" class="text-lg font-bold mb-2 text-gray-800">Alert</h3>
        <p id="messageText" class="text-sm text-gray-600 mb-4">Content</p>
        <button onclick="document.getElementById('messageBox').classList.remove('visible')"
            class="w-full bg-indigo-600 text-white py-2 rounded-lg hover:bg-indigo-700">
            OK
        </button>
    </div>

    <!-- Header (Compacted) -->
    <header class="bg-blue-900 shadow-xl z-[4000] p-3 flex flex-col gap-3 flex-none fixed top-0 left-0 right-0"
        style="position: fixed !important; top: 0 !important;">

        <!-- Title and Controls Row 1 -->
        <div class="flex flex-col md:flex-row items-center justify-between gap-3">
            <div class="text-center md:text-left">
                <h1 class="text-xl font-bold text-white leading-tight">Historic Places Explorer <span
                        class="bg-yellow-400 text-blue-900 text-xs font-bold px-2 py-1 rounded-md ml-2">v5.40</span>
                </h1>
                <p class="text-indigo-200 text-xs hidden sm:block">Real-time Wikipedia Landmarks & Tour Guide</p>
            </div>

            <!-- Controls Group Row 1 -->
            <div class="flex flex-wrap items-center justify-center gap-3">

                <!-- Location Dropdown -->
                <div class="relative">
                    <button onclick="document.getElementById('locationDropdown').classList.toggle('hidden')"
                        class="bg-indigo-500 hover:bg-indigo-400 text-white text-xs font-bold py-2 px-3 rounded-lg shadow transition flex items-center gap-1">
                        <span>Location</span>
                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7">
                            </path>
                        </svg>
                    </button>
                    <!-- Dropdown Menu -->
                    <div id="locationDropdown"
                        class="hidden absolute top-full right-0 mt-2 w-48 bg-white rounded-lg shadow-xl py-2 z-50 border border-gray-100">
                        <button
                            onclick="changeLocation(38.8893, -77.0502, 'Washington D.C.'); document.getElementById('locationDropdown').classList.add('hidden')"
                            class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-indigo-50">Washington
                            D.C.</button>
                        <button
                            onclick="changeLocation(40.7580, -73.9855, 'Midtown Manhattan'); document.getElementById('locationDropdown').classList.add('hidden')"
                            class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-indigo-50">Midtown
                            Manhattan</button>
                        <button
                            onclick="changeLocation(51.5074, 0.1278, 'London'); document.getElementById('locationDropdown').classList.add('hidden')"
                            class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-indigo-50">London,
                            UK</button>
                    </div>
                </div>

                <!-- Enable Compass Button (FALLBACK ONLY - Hidden initially) -->
                <button id="enableCompassBtn" onclick="handleCompassPermissionRequest()"
                    class="bg-yellow-500 hover:bg-yellow-600 text-gray-900 text-xs font-bold py-2 px-3 rounded-lg shadow transition whitespace-nowrap hidden">
                    Enable Compass
                </button>

                <!-- Tour Button -->
                <button id="startTourButton" onclick="openTourPanel()"
                    class="bg-emerald-500 hover:bg-emerald-600 text-white text-xs font-bold py-2 px-3 rounded-lg shadow transition whitespace-nowrap">
                    Start Tour
                </button>
            </div>
        </div>


    </header>


    <!-- Tour Panel (Slide-up Card with Tabs) -->
    <div id="tourPanel" style="padding-bottom: calc(env(safe-area-inset-bottom, 20px) + 1rem);"
        class="fixed inset-x-0 bottom-0 bg-white text-gray-800 p-3 sm:p-4 shadow-2xl rounded-t-3xl transition-all duration-300 transform translate-y-full opacity-0 z-[5000] max-h-[65vh] overflow-y-auto">
        <div class="max-w-4xl mx-auto flex flex-col">

            <!-- Header with Close Button -->
            <div class="flex justify-between items-center mb-2">
                <h3 class="text-xl font-bold text-indigo-700">Configure Tour</h3>
                <button onclick="closeTourPanel()" class="text-gray-400 hover:text-gray-600 transition">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12">
                        </path>
                    </svg>
                </button>
            </div>

            <!-- Tab Navigation -->
            <div class="flex gap-2 mb-3 border-b border-gray-200">
                <button onclick="switchTab('distance')" id="tab-distance"
                    class="flex-1 py-3 text-sm font-medium text-indigo-600 border-b-2 border-indigo-600 focus:outline-none transition-colors duration-200">
                    Roam
                </button>
                <button id="customTabBtn" onclick="switchTourTab('custom')"
                    class="px-4 py-2 font-semibold text-gray-500 border-b-2 border-transparent hover:text-indigo-600 transition">
                    Custom Tour
                </button>
                <button id="settingsTabBtn" onclick="switchTourTab('settings')"
                    class="px-4 py-2 font-semibold text-gray-500 border-b-2 border-transparent hover:text-indigo-600 transition">
                    Settings
                </button>
            </div>

            <!-- Distance-Based Tour Tab -->
            <div id="distanceTab" class="tour-tab">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-lg font-bold text-gray-800">Roam Mode</h2>
                    <button id="compassStatusBtn" onclick="startRoaming()"
                        class="text-xs font-mono bg-gray-100 text-gray-500 px-2 py-1 rounded hover:bg-gray-200 transition">
                        Compass Inactive
                    </button>
                </div>
                <p class="text-sm text-gray-500 mb-4">Point your phone at landmarks to identify them automatically.</p>

                <button id="startRoamingBtn" onclick="startRoaming()"
                    class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-xl transition duration-200 shadow-lg mb-2">
                    Start Roaming
                </button>

                <button id="stopRoamingBtn" onclick="stopRoaming()"
                    class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-6 rounded-xl transition duration-200 shadow-lg hidden">
                    Stop Roaming
                </button>
            </div>

            <!-- Custom Tour Tab -->
            <div id="customTab" class="tour-tab hidden">
                <p class="text-xs text-gray-600 mb-2">Select landmarks to visit:</p>

                <!-- Selected Count -->
                <div class="mb-2 flex items-center gap-2">
                    <span class="text-sm font-semibold text-indigo-600">Selected: <span
                            id="selectedCount">0</span></span>
                    <button onclick="clearSelectedLandmarks()"
                        class="text-xs text-red-500 hover:text-red-700 underline">Clear All</button>
                </div>

                <!-- Horizontal Scrollable Landmark Cards -->
                <div id="landmarkCardsContainer"
                    class="flex gap-2 overflow-x-auto pb-2 mb-2 snap-x snap-mandatory scrollbar-hide">
                    <!-- Cards will be dynamically inserted here -->
                    <div class="text-center text-gray-400 py-8 w-full">
                        <p>Loading landmarks...</p>
                    </div>
                </div>

                <!-- Status Text -->
                <p id="tourStatus" class="text-xs text-gray-500 mb-2">Creates an optimized route through your selected
                    stops.</p>

                <button id="createCustomTourBtn" onclick="handleCreateCustomTour()" disabled
                    class="w-full bg-indigo-600 hover:bg-indigo-700 disabled:bg-gray-400 text-white font-bold py-3 px-6 rounded-xl transition duration-200 shadow-lg">
                    Start Custom Tour
                </button>
            </div>

            <!-- Settings Tab -->
            <div id="settingsTab" class="tour-tab hidden">
                <div class="mb-4">
                    <label for="geminiApiKey" class="block text-sm font-semibold text-gray-700 mb-2">
                        Gemini API Key (for AI Summaries)
                    </label>
                    <input type="password" id="geminiApiKey" placeholder="Enter your API Key"
                        class="block w-full rounded-xl border-2 border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 text-lg p-3 mb-2">
                    <p class="text-xs text-gray-500">
                        Required for AI-generated summaries. Get a key from <a
                            href="https://aistudio.google.com/app/apikey" target="_blank"
                            class="text-indigo-600 underline">Google AI Studio</a>.
                    </p>
                </div>
                <button onclick="saveSettings()"
                    class="w-full bg-gray-800 hover:bg-gray-900 text-white font-bold py-3 px-6 rounded-xl transition duration-200 shadow-lg">
                    Save Settings
                </button>
            </div>

            <!-- Knowledge Panel (Slide-up Card) -->
            <div id="knowledgePanel"
                class="fixed inset-x-0 bottom-0 bg-white text-gray-800 shadow-2xl rounded-t-3xl transition-all duration-300 transform translate-y-full opacity-0 z-[4000] max-h-[70vh] flex flex-col overflow-hidden">

                <!-- Sticky Header Section -->
                <div class="flex-shrink-0 bg-white z-20 px-4 pt-4 sm:px-6 sm:pt-6 rounded-t-3xl shadow-sm relative">
                    <div class="max-w-4xl mx-auto flex justify-between items-start mb-2">
                        <div class="flex items-center gap-3">
                            <!-- Compass Widget -->
                            <div class="relative w-16 h-16 flex-shrink-0">
                                <!-- Indigo Circle Background -->
                                <div
                                    class="absolute inset-0 bg-indigo-100 rounded-full border-2 border-indigo-500 box-border">
                                </div>

                                <!-- Curved Text SVG -->
                                <svg class="absolute inset-0 w-full h-full pointer-events-none" viewBox="0 0 100 100">
                                    <defs>
                                        <path id="curve" d="M 20, 50 a 30,30 0 1,1 60,0" />
                                    </defs>
                                    <text width="100" text-anchor="middle">
                                        <textPath xlink:href="#curve" startOffset="50%" id="compassTextPath"
                                            class="text-[12px] font-bold fill-indigo-700 uppercase tracking-wider">
                                            ...
                                        </textPath>
                                    </text>
                                </svg>

                                <!-- Arrow Icon -->
                                <div id="panelCompassArrow"
                                    class="absolute inset-0 flex items-center justify-center transition-transform duration-75 ease-linear origin-center">
                                    <svg class="w-8 h-8 text-indigo-600 fill-current" viewBox="0 0 24 24">
                                        <path
                                            d="M12 2L4.5 20.29C4.24 20.89 4.81 21.5 5.43 21.27L12 18.5L18.57 21.27C19.19 21.5 19.76 20.89 19.5 20.29L12 2Z" />
                                    </svg>
                                </div>
                            </div>

                            <h3 class="text-2xl font-bold text-indigo-700 leading-tight" id="knowledgePanelTitle">
                                Landmark Details</h3>
                        </div>

                        <button onclick="closeKnowledgePanel()"
                            class="text-gray-400 hover:text-gray-600 transition p-2">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M6 18L18 6M6 6l12 12">
                                </path>
                            </svg>
                        </button>
                    </div>
                </div>

                <!-- Scrollable Content Section -->
                <div class="flex-grow overflow-y-auto bg-white px-4 pb-4 sm:px-6 sm:pb-6"
                    style="padding-bottom: calc(env(safe-area-inset-bottom, 20px) + 1rem);">
                    <div class="max-w-4xl mx-auto flex flex-col pt-2">

                        <!-- Image -->
                        <div id="knowledgePanelImageContainer"
                            class="mb-4 rounded-xl overflow-hidden bg-gray-100 flex-shrink-0">
                            <img id="knowledgePanelImage" src="" alt="" class="w-full h-64 object-cover">
                        </div>

                        <!-- Construction Date -->
                        <p id="knowledgePanelDate" class="text-sm text-gray-500 mb-3 hidden"></p>

                        <!-- Description -->
                        <div id="knowledgePanelDescription"
                            class="prose prose-indigo max-w-none mb-6 text-gray-700 leading-relaxed">
                            <!-- Content injected here -->
                        </div>

                        <!-- Wikipedia Link -->
                        <a id="knowledgePanelLink" href="#" target="_blank"
                            class="inline-flex items-center justify-center w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-xl transition duration-200 shadow-lg mb-4">
                            Read on Wikipedia
                            <svg class="w-4 h-4 ml-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14">
                                </path>
                            </svg>
                        </a>

                        <!-- Settings Button (Moved here for consistency if needed, but kept hidden/optional) -->
                    </div>
                </div>
            </div>

            <style>
                /* Hide scrollbar for Chrome, Safari and Opera */
                .scrollbar-hide::-webkit-scrollbar {
                    display: none;
                }

                /* Hide scrollbar for IE, Edge and Firefox */
                .scrollbar-hide {
                    -ms-overflow-style: none;
                    scrollbar-width: none;
                }
            </style>

            <!-- Map Container -->
            <div id="map-wrapper" class="absolute inset-0 overflow-hidden z-0">
                <div id="map" class="w-full h-full bg-gray-200"></div>
            </div>

            <!-- Loading Overlay -->
            <div id="loadingOverlay"
                class="hidden fixed inset-0 bg-black/50 backdrop-blur-sm z-[9000] flex items-center justify-center">
                <div class="bg-white rounded-2xl p-8 shadow-2xl flex flex-col items-center gap-4 max-w-sm mx-4">
                    <div class="relative w-16 h-16">
                        <div class="absolute inset-0 border-4 border-indigo-200 rounded-full"></div>
                        <div
                            class="absolute inset-0 border-4 border-indigo-600 rounded-full border-t-transparent animate-spin">
                        </div>
                    </div>
                    <h3 class="text-xl font-bold text-gray-800">Generating Route</h3>
                    <p id="loadingText" class="text-sm text-gray-600 text-center">Calculating optimal walking paths...
                    </p>
                    <div class="w-full bg-gray-200 rounded-full h-2 overflow-hidden">
                        <div id="loadingProgress" class="bg-indigo-600 h-full transition-all duration-300"
                            style="width: 0%">
                        </div>
                    </div>
                </div>
            </div>

            <!-- Location Status Bubble (REPOSITIONED & Compacted) -->
            <div id="locationStatus"
                class="fixed top-24 left-1/2 transform -translate-x-1/2 bg-white/90 backdrop-blur-sm px-4 py-2 rounded-full shadow-xl z-[6000] flex items-center gap-3 transition-opacity duration-500 w-11/12 max-w-3xl border border-gray-200">
                <div id="statusIndicator" class="w-2 h-2 bg-red-500 rounded-full animate-pulse flex-shrink-0"></div>
                <span
                    class="text-sm font-medium text-gray-800 whitespace-nowrap overflow-hidden text-ellipsis flex-grow"
                    id="locationStatusText">Locating...</span>
                <!-- Enable Compass Button (shown when needed) -->
                <button id="enableCompassBtnInStatus" onclick="handleCompassPermissionRequest()"
                    class="hidden bg-yellow-500 hover:bg-yellow-600 text-gray-900 text-xs font-bold py-1 px-3 rounded-lg shadow transition whitespace-nowrap">
                    Enable Compass
                </button>
            </div>

            <!-- NAVIGATION PANEL (Green Bar - Fixed to Bottom) -->
            <div id="navigationPanel" style="padding-bottom: calc(env(safe-area-inset-bottom, 20px) + 2rem);"
                class="fixed inset-x-0 bottom-0 bg-green-600 text-white p-4 sm:p-6 shadow-2xl rounded-t-3xl transition-all duration-300 transform translate-y-full opacity-0 z-[5000] min-h-[12rem] h-auto">
                <div class="max-w-xl mx-auto flex flex-col h-full">

                    <!-- Current Step Display -->
                    <div class="flex items-start space-x-3 mb-2">
                        <svg id="navInstructionIcon" class="w-6 h-6 flex-shrink-0 mt-1" fill="currentColor"
                            viewBox="0 0 24 24">
                            <path
                                d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17.93c-3.95-.49-7-3.41-7-7.38 0-.47.05-.93.14-1.39l5.86 5.86v2.91zm5.93-5.07l-5.86-5.86c.46-.09.92-.14 1.39-.14 3.97 0 6.89 3.05 7.38 7zm-5.93-10.79l5.86 5.86c-.46-.09-.92-.14-1.39-.14-3.97 0-6.89-3.05-7.38-7zm-5.93 5.07l5.86 5.86c-.46.09-.92-.14-1.39-.14-3.97 0-6.89-3.05-7.38-7z" />
                        </svg>
                        <h2 id="currentNavInstruction" class="text-xl sm:text-2xl font-semibold leading-tight">Waiting
                            for
                            Tour...</h2>
                    </div>

                    <!-- Next Steps & Progress -->
                    <div class="flex justify-between items-end mt-1 mb-2 border-t border-green-500 pt-3">
                        <p id="nextLandmarkInfo" class="text-sm opacity-90 leading-relaxed max-w-[70%]">Next: Please
                            start a
                            tour using the button above.</p>
                        <p id="navStepCounter" class="text-sm font-medium opacity-80 flex-shrink-0 ml-4">0/0</p>
                    </div>

                    <!-- Tour Statistics -->
                    <div id="tourStats"
                        class="hidden mb-4 bg-green-700/50 rounded-xl p-3 flex items-center justify-around gap-2">
                        <div class="flex items-center gap-2">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7">
                                </path>
                            </svg>
                            <span id="tourDistance" class="text-sm font-semibold">0.0 mi</span>
                        </div>
                        <div class="w-px h-6 bg-green-400/50"></div>
                        <div class="flex items-center gap-2">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                            <span id="tourDuration" class="text-sm font-semibold">0 min</span>
                        </div>
                    </div>

                    <!-- Action Button -->
                    <div class="flex-grow flex items-end">
                        <button id="navActionButton" onclick="nextSegment()"
                            class="w-full bg-white text-green-600 font-bold py-3 px-6 rounded-xl hover:bg-gray-100 transition duration-200 shadow-lg">
                            Next Stop
                        </button>
                    </div>
                </div>
            </div>


            <script>
                // Global State
                let map;
                let userMarker = null;
                let landmarkMarkers = new L.LayerGroup();
                let tourRoute = null; // Array of {lat, lon, title, steps, ...} objects
                let tourPath = null; // The Leaflet Polyline/Route object
                let tourPoints = []; // Populated by GeoSearch
                const WIKIPEDIA_API_URL = 'https://en.wikipedia.org/w/api.php';
                // Using OSRM Public Server for routing
                const OSRM_API_URL = 'https://router.project-osrm.org/route/v1/foot/';
                let isFetching = false; // Prevent multiple concurrent fetches

                let currentTourStep = 0; // 0 = ready to start, 1+ = navigating to this stop index
                let watchingPosition = false;
                let watchId = null;
                let currentManeuverIndex = -1; // Index of the next maneuver in the OSRM steps array

                // NEW: State for compass permission AND the live heading data
                let isCompassPermissionRequested = false;
                let currentSensorHeading = null; // Stores live heading from deviceorientation sensor

                // CONSTANT: Fixed search radius in kilometers (5 miles is approx 8.04672 km, sticking to 5km for precision)
                const FIXED_SEARCH_RADIUS_KM = 10;

                // Custom Marker Icon for User Location (Simple Arrow)
                const userArrowIcon = L.divIcon({
                    className: 'user-arrow-marker bg-indigo-600 rounded-full border-4 border-white shadow-xl',
                    iconSize: [40, 40],
                    // HTML for the CSS triangle indicator
                    html: '<div id="userDirectionArrow"></div>',
                    popupAnchor: [0, -10]
                });

                // Landmark Marker Icon (A simple red dot for historic sites)
                const landmarkIcon = L.divIcon({
                    className: 'bg-red-600 rounded-full border-2 border-white shadow-lg',
                    iconSize: [12, 12]
                });

                // Utility: Custom Alert/Modal Box
                const showMessage = (title, text) => {
                    document.getElementById('messageTitle').textContent = title;
                    document.getElementById('messageText').textContent = text;
                    document.getElementById('messageBox').classList.add('visible');
                };

                // Utility: Exponential Backoff for Fetch
                const fetchWithRetry = async (url, options = {}, retries = 3) => {
                    for (let i = 0; i < retries; i++) {
                        try {
                            const response = await fetch(url, options);
                            if (!response.ok) {
                                throw new Error(`HTTP error! status: ${response.status}`);
                            }
                            return await response.json();
                        } catch (error) {
                            if (i < retries - 1) {
                                const delay = Math.pow(2, i) * 1000;
                                await new Promise(resolve => setTimeout(resolve, delay));
                            } else {
                                throw error;
                            }
                        }
                    }
                };

                // Utility: Haversine distance calculation in meters
                const getDistance = (lat1, lon1, lat2, lon2) => {
                    const R = 6371e3; // metres
                    const φ1 = lat1 * Math.PI / 180;
                    const φ2 = lat2 * Math.PI / 180;
                    const Δφ = (lat2 - lat1) * Math.PI / 180;
                    const Δλ = (lon2 - lon1) * Math.PI / 180;

                    const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                        Math.cos(φ1) * Math.cos(φ2) *
                        Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
                    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

                    return R * c; // Distance in meters
                }

                // --- UTILITY FUNCTION: CARDINAL DIRECTION CONVERSION ---
                /**
                 * Converts a numerical heading (0-360 degrees) into a cardinal direction string (e.g., "N", "SW").
                 * @param {number} degrees - The heading in degrees.
                 * @returns {string} The cardinal direction.
                 */
                function getCardinalDirection(degrees) {
                    if (degrees === null || typeof degrees === 'undefined' || isNaN(degrees)) {
                        return 'N/A';
                    }

                    // Normalize degrees to 0-360
                    degrees = (degrees % 360 + 360) % 360;

                    const directions = ["N", "NNE", "NE", "ENE", "E", "ESE", "SE", "SSE", "S", "SSW", "SW", "WSW", "W", "WNW", "NW", "NNW"];
                    // Each direction covers 360 / 16 = 22.5 degrees.
                    // Half a sector is 22.5 / 2 = 11.25 degrees.
                    // We shift the heading by half a sector and divide by the sector size.
                    const index = Math.floor((degrees + 11.25) / 22.5);

                    return directions[index % 16];
                }
                // --- END UTILITY FUNCTION ---


                // --- UNIFIED ORIENTATION HANDLER ---
                let isOrientationPending = false;
                let pendingOrientationEvent = null;

                const handleDeviceOrientation = (event) => {
                    pendingOrientationEvent = event;
                    if (!isOrientationPending) {
                        isOrientationPending = true;
                        requestAnimationFrame(processOrientationUpdate);
                    }
                };

                const processOrientationUpdate = () => {
                    if (!pendingOrientationEvent) {
                        isOrientationPending = false;
                        return;
                    }

                    const event = pendingOrientationEvent;

                    // 1. Calculate Heading
                    let heading = null;
                    if (event.webkitCompassHeading !== undefined && event.webkitCompassHeading !== null) {
                        heading = event.webkitCompassHeading;
                    } else if (event.alpha !== undefined && event.alpha !== null) {
                        heading = (360 - event.alpha + 360) % 360;
                    }

                    if (heading !== null) {
                        currentHeading = heading;
                        currentSensorHeading = heading;

                        // 2. Update Main User Arrow (Header/Map)
                        const arrow = document.getElementById('userDirectionArrow');
                        const locationStatusText = document.getElementById('locationStatusText');

                        if (arrow) arrow.style.transform = `rotate(${heading}deg)`;

                        if (locationStatusText) {
                            const cardinal = getCardinalDirection(heading);
                            locationStatusText.innerHTML = `<span class="text-indigo-600 font-bold">${cardinal} (${heading.toFixed(1)}°)</span>`;
                        }

                        // 3. Update Map Elements (FOV & Panel Compass)
                        if (userMarker) {
                            const latLng = userMarker.getLatLng();

                            // Update FOV Cone
                            if (isRoaming) {
                                updateFOVCone(latLng, heading);

                                // Restore Roam Mode Centering
                                // Calculate target center by applying offset
                                // We want the user marker to be 'roamCenterOffset' pixels BELOW the center
                                // So the map center must be 'roamCenterOffset' pixels ABOVE the user marker
                                const zoom = 18;
                                const point = map.project(latLng, zoom);
                                const targetPoint = point.subtract([0, roamCenterOffset]);
                                const targetCenter = map.unproject(targetPoint, zoom);

                                map.setView(targetCenter, zoom, { animate: false });
                            }

                            // Update Panel Compass
                            updatePanelCompass(latLng, heading);
                        }
                    }

                    isOrientationPending = false;
                };

                // --- ROAM MODE LOGIC ---

                let isRoaming = false;
                let roamInterval = null;
                let currentHeading = 0;
                let lastTriggeredLandmark = null;
                let roamCenterOffset = 0;

                const updateRoamOffset = () => {
                    const header = document.querySelector('header');
                    const headerHeight = header ? header.offsetHeight : 0;
                    const screenHeight = window.innerHeight;
                    // Target Y is center of the space below header
                    const targetY = headerHeight + (screenHeight - headerHeight) / 2;
                    const centerY = screenHeight / 2;
                    // Offset is how much we need to shift the center UP (so subtract this from Y)
                    // If targetY > centerY (marker is lower), offset is positive.
                    roamCenterOffset = targetY - centerY;
                };

                const startRoaming = async () => {
                    // Request permission for iOS 13+
                    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                        try {
                            const response = await DeviceOrientationEvent.requestPermission();
                            if (response !== 'granted') {
                                alert('Compass permission is required for Roam Mode.');
                                return;
                            }
                        } catch (e) {
                            console.error(e);
                        }
                    }

                    isRoaming = true;
                    window.addEventListener('deviceorientation', handleDeviceOrientation); // Use unified handler
                    window.addEventListener('resize', updateRoamOffset);

                    // Calculate initial offset
                    updateRoamOffset();

                    // Start FOV Loop
                    roamInterval = setInterval(checkFOV, 1000); // Check every second

                    // Update UI - Hide Panel & Change Header Button
                    closeTourPanel();
                    // "change the 'start tour' button in the header" -> The header just has the title.
                    // Let's look at the header again.
                    // <header> ... <h1> ... <button id="menuBtn"> ... </header>
                    // There is no start tour button in the header.
                    // Maybe they mean the "Create Tour" button in the tab?
                    // "When you click 'start roaming' Make the configure tour popup hide" -> Done (closeTourPanel)
                    // "and change the 'start tour' button in the header to a 'stop roaming' button"
                    // I will inject a "Stop Roaming" button into the header area or replace the menu button?
                    const tourBtn = document.getElementById('startTourButton');
                    if (tourBtn) {
                        tourBtn.textContent = "Stop Roaming";
                        tourBtn.onclick = stopRoaming;
                        tourBtn.classList.replace('bg-emerald-500', 'bg-red-500');
                        tourBtn.classList.replace('hover:bg-emerald-600', 'hover:bg-red-600');
                    }

                    // Update Compass Button Status
                    const compassBtn = document.getElementById('compassStatusBtn');
                    if (compassBtn) {
                        compassBtn.textContent = "Compass Active";
                        compassBtn.classList.replace('text-gray-500', 'text-green-600');
                        compassBtn.classList.replace('bg-gray-100', 'bg-green-100');
                    }

                    // Disable Map Interaction & Hide Controls
                    map.dragging.disable();
                    map.touchZoom.disable();
                    map.doubleClickZoom.disable();
                    map.scrollWheelZoom.disable();
                    map.boxZoom.disable();
                    map.keyboard.disable();
                    if (map.tap) map.tap.disable();

                    document.querySelector('.leaflet-control-container').style.display = 'none';
                };

                const stopRoaming = () => {
                    isRoaming = false;
                    window.removeEventListener('deviceorientation', handleDeviceOrientation); // Use unified handler
                    window.removeEventListener('resize', updateRoamOffset);
                    clearInterval(roamInterval);

                    // Reset Map Rotation & Scale (Just in case)
                    const mapContainer = document.getElementById('map');
                    mapContainer.style.transform = '';

                    // Remove FOV Cone if exists
                    if (fovCone) {
                        map.removeLayer(fovCone);
                        fovCone = null;
                    }

                    // Re-enable Map Interaction & Show Controls
                    map.dragging.enable();
                    map.touchZoom.enable();
                    map.doubleClickZoom.enable();
                    map.scrollWheelZoom.enable();
                    map.boxZoom.disable();
                    map.keyboard.enable();
                    if (map.tap) map.tap.enable();

                    document.querySelector('.leaflet-control-container').style.display = 'block';

                    // Update UI
                    openTourPanel();

                    const tourBtn = document.getElementById('startTourButton');
                    if (tourBtn) {
                        tourBtn.textContent = "Start Tour";
                        tourBtn.onclick = openTourPanel;
                        tourBtn.classList.replace('bg-red-500', 'bg-emerald-500');
                        tourBtn.classList.replace('hover:bg-red-600', 'hover:bg-emerald-600');
                    }

                    const compassBtn = document.getElementById('compassStatusBtn');
                    if (compassBtn) {
                        compassBtn.textContent = "Compass Inactive";
                        compassBtn.classList.replace('text-green-600', 'text-gray-500');
                        compassBtn.classList.replace('bg-green-100', 'bg-gray-100');
                    }
                };
                // --- VISUAL FOV CONE ---
                let fovCone = null;

                const updateFOVCone = (center, heading) => {
                    const radius = 46; // 150 feet ~= 46 meters
                    const angle = 30; // +/- 30 degrees (Narrower)

                    // Calculate vertices of the cone (Sector/Pie Slice)
                    // Point 1: Center (User)
                    const latLngs = [center];

                    // Helper to get destination point given distance and bearing
                    const getDestinationPoint = (lat, lng, dist, brng) => {
                        const R = 6371000; // Earth radius in meters
                        const latRad = lat * (Math.PI / 180);
                        const lngRad = lng * (Math.PI / 180);
                        const brngRad = brng * (Math.PI / 180);

                        const lat2 = Math.asin(Math.sin(latRad) * Math.cos(dist / R) +
                            Math.cos(latRad) * Math.sin(dist / R) * Math.cos(brngRad));
                        const lng2 = lngRad + Math.atan2(Math.sin(brngRad) * Math.sin(dist / R) * Math.cos(latRad),
                            Math.cos(dist / R) - Math.sin(latRad) * Math.sin(lat2));

                        return [lat2 * (180 / Math.PI), lng2 * (180 / Math.PI)];
                    };

                    // Generate points along the arc
                    const startBearing = (heading - angle + 360) % 360;
                    const endBearing = (heading + angle + 360) % 360;

                    // We need to handle the wrap-around at 360
                    let currentB = startBearing;
                    const step = 5; // Degree step for smoothness

                    // If end is smaller than start, we crossed 360
                    const totalSweep = angle * 2;

                    for (let i = 0; i <= totalSweep; i += step) {
                        const b = (startBearing + i) % 360;
                        latLngs.push(getDestinationPoint(center.lat, center.lng, radius, b));
                    }
                    // Ensure we hit the exact end
                    latLngs.push(getDestinationPoint(center.lat, center.lng, radius, endBearing));

                    // Close the polygon (back to center is implicit in Leaflet polygon but good to be explicit order)
                    // Leaflet closes it automatically.

                    if (fovCone) {
                        fovCone.setLatLngs(latLngs);
                    } else {
                        fovCone = L.polygon(latLngs, {
                            color: '#4f46e5', // Indigo-600
                            fillColor: '#6366f1', // Indigo-500
                            fillOpacity: 0.2,
                            weight: 1,
                            dashArray: '5, 5'
                        }).addTo(map);
                    }
                };

                // --- PANEL COMPASS LOGIC ---
                let currentLandmarkLocation = null;

                const updatePanelCompass = (userPos, heading) => {
                    if (!currentLandmarkLocation) {
                        return;
                    }

                    const dist = getDistance(userPos.lat, userPos.lng, currentLandmarkLocation.lat, currentLandmarkLocation.lon);
                    const bearing = getBearing(userPos.lat, userPos.lng, currentLandmarkLocation.lat, currentLandmarkLocation.lon);

                    // Calculate relative rotation for the arrow
                    let arrowRotation = bearing - heading;

                    // Update Arrow Rotation
                    const arrow = document.getElementById('panelCompassArrow');
                    if (arrow) {
                        arrow.style.transform = `rotate(${arrowRotation}deg)`;
                    }

                    // Update Distance Text
                    const textPath = document.getElementById('compassTextPath');
                    if (textPath) {
                        const feet = Math.round(dist * 3.28084);
                        textPath.textContent = `${feet} ft`;
                    }
                };

                const checkFOV = () => {
                    if (!userMarker) return;

                    const userPos = userMarker.getLatLng();
                    const FOV_ANGLE = 30; // +/- 30 degrees
                    const MAX_DIST_METERS = 46; // 150 feet

                    // Find closest landmark in FOV
                    let closestTarget = null;
                    let minDist = Infinity;

                    // Iterate through all loaded landmarks (from tourPoints)
                    // We use tourPoints because it contains the full data we need
                    tourPoints.forEach(p => {
                        const dist = getDistance(userPos.lat, userPos.lng, p.lat, p.lon);

                        if (dist < MAX_DIST_METERS) {
                            const bearing = getBearing(userPos.lat, userPos.lng, p.lat, p.lon);

                            // Calculate angle difference
                            let angleDiff = Math.abs(currentHeading - bearing);
                            if (angleDiff > 180) angleDiff = 360 - angleDiff;

                            if (angleDiff <= FOV_ANGLE) {
                                if (dist < minDist) {
                                    minDist = dist;
                                    closestTarget = p;
                                }
                            }
                        }
                    });

                    if (closestTarget) {
                        // Debounce: Don't re-trigger the same one immediately
                        if (lastTriggeredLandmark !== closestTarget.title) {
                            lastTriggeredLandmark = closestTarget.title;

                            // Auto-open panel
                            // We need to find the marker ID if possible, or just pass 0
                            const markerId = closestTarget.marker ? closestTarget.marker._leaflet_id : 0;
                            // Pass coordinates directly to ensure compass works
                            openKnowledgePanel(closestTarget.title, markerId, closestTarget.lat, closestTarget.lon);

                            // Vibrate if supported
                            if (navigator.vibrate) navigator.vibrate(200);
                        }
                    } else {
                        // Reset if we moved away
                        // Optional: only reset if we are FAR from the last one
                    }
                };

                const getBearing = (startLat, startLng, destLat, destLng) => {
                    const startLatRad = startLat * (Math.PI / 180);
                    const startLngRad = startLng * (Math.PI / 180);
                    const destLatRad = destLat * (Math.PI / 180);
                    const destLngRad = destLng * (Math.PI / 180);

                    const y = Math.sin(destLngRad - startLngRad) * Math.cos(destLatRad);
                    const x = Math.cos(startLatRad) * Math.sin(destLatRad) -
                        Math.sin(startLatRad) * Math.cos(destLatRad) * Math.cos(destLngRad - startLngRad);

                    let brng = Math.atan2(y, x);
                    brng = brng * (180 / Math.PI);
                    return (brng + 360) % 360;
                };

                // --- UPDATED: COMPASS PERMISSION LOGIC ---

                /**
                 * Requests permission to access Device Orientation data (compass/sensors).
                 */
                const handleCompassPermissionRequest = () => {
                    const btn = document.getElementById('enableCompassBtn');
                    const btnInStatus = document.getElementById('enableCompassBtnInStatus');
                    const statusIndicator = document.getElementById('statusIndicator');

                    btn.classList.add('hidden'); // Hide header button while requesting
                    btnInStatus.classList.add('hidden'); // Hide status button while requesting

                    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                        DeviceOrientationEvent.requestPermission()
                            .then(permissionState => {
                                if (permissionState === 'granted') {
                                    isCompassPermissionRequested = true;
                                    // SUCCESS: Attach the listener
                                    window.addEventListener('deviceorientation', handleDeviceOrientation);
                                    // Turn indicator green
                                    statusIndicator.className = 'w-2 h-2 bg-green-500 rounded-full animate-pulse flex-shrink-0';
                                } else {
                                    // DENIED: Show the button as a fallback/retry option
                                    isCompassPermissionRequested = false;
                                    btnInStatus.classList.remove('hidden');
                                    showMessage("Compass Access Needed", "Heading data was denied. Click 'Enable Compass' to try again.");
                                }
                            })
                            .catch(error => {
                                console.error('Error requesting device orientation permission:', error);
                                isCompassPermissionRequested = false;
                                btnInStatus.classList.remove('hidden'); // Show status button on error
                            });
                    } else {
                        // Non-iOS or older browsers: assume permission is implicit.
                        // Unified Orientation Handler
                        if (window.DeviceOrientationEvent) {
                            window.addEventListener('deviceorientation', handleDeviceOrientation);
                            isCompassPermissionRequested = true;
                            // Turn indicator green since compass is available
                            statusIndicator.className = 'w-2 h-2 bg-green-500 rounded-full animate-pulse flex-shrink-0';
                        } else {
                            console.warn("DeviceOrientationEvent not supported.");
                        }
                        btn.classList.add('hidden');
                        btnInStatus.classList.add('hidden');
                    }
                };

                // --- ROUTING & NAVIGATION FUNCTIONS (Unchanged) ---
                // ... (fetchWalkingRoute, findNextManeuver unchanged) ...

                /**
                 * Fetches a detailed walking route with steps from OSRM.
                 */
                const fetchWalkingRoute = async (startLat, startLon, endLat, endLon) => {
                    // OSRM expects coordinates in [lon, lat] format
                    const coordinates = `${startLon},${startLat};${endLon},${endLat}`;
                    // Request polyline geometry AND steps
                    const url = `${OSRM_API_URL}${coordinates}?geometries=polyline&steps=true&overview=full`;

                    try {
                        const data = await fetchWithRetry(url);

                        if (data.routes && data.routes.length > 0) {
                            const route = data.routes[0];
                            const leg = route.legs[0];

                            const polylineString = route.geometry;

                            const decodedPath = polyline.decode(polylineString);

                            return {
                                path: decodedPath,
                                distance: route.distance,
                                duration: route.duration,
                                steps: leg.steps // The turn-by-turn instructions
                            };
                        } else {
                            console.error("No routes in OSRM response");
                            throw new Error("No route found by OSRM.");
                        }
                    } catch (error) {
                        console.error("OSRM Routing Error:", error);
                        // Silently return null - caller will handle fallback
                        return null;
                    }
                }

                /**
                 * Finds the next maneuver instruction the user needs to follow.
                 */
                const findNextManeuver = (userLat, userLon, targetSteps) => {
                    if (!targetSteps || targetSteps.length === 0) {
                        return { instruction: "Continue to your destination.", distance: 0, finished: true };
                    }

                    let bestStep = targetSteps[targetSteps.length - 1]; // Default to the last step (arrival)
                    let minDistance = Infinity;
                    let maneuverIndex = -1;

                    // Iterate through steps, looking for the *closest* maneuver point that hasn't been passed
                    // The OSRM steps contain the maneuver location in the 'location' array (lon, lat)
                    for (let i = 0; i < targetSteps.length; i++) {
                        const step = targetSteps[i];
                        // Step location is [lon, lat]
                        const stepLon = step.maneuver.location[0];
                        const stepLat = step.maneuver.location[1];

                        const distanceToStep = getDistance(userLat, userLon, stepLat, stepLon);

                        // If the user is close enough (e.g., within 20m) and we haven't checked this one,
                        // we treat the next one as the current target.
                        if (distanceToStep > 20) {
                            // Since we iterate sequentially, the first step we find that is > 20m away
                            // from the maneuver point is the 'next' one to aim for.
                            if (distanceToStep < minDistance) {
                                minDistance = distanceToStep;
                                bestStep = step;
                                maneuverIndex = i;
                                break; // Found the target maneuver
                            }
                        }
                    }

                    // Handle arrival (last step)
                    if (maneuverIndex === -1 || maneuverIndex === targetSteps.length - 1) {
                        return { instruction: "Arriving at your destination!", distance: getDistance(userLat, userLon, tourRoute[currentTourStep].lat, tourRoute[currentTourStep].lon), finished: true, index: targetSteps.length - 1 };
                    }

                    // Return the instruction and the distance to the maneuver location
                    let instructionText = bestStep.maneuver.instruction; // Try default first

                    // If OSRM doesn't provide a pre-formatted string, construct one
                    if (!instructionText || instructionText === "undefined") {
                        const type = bestStep.maneuver.type; // e.g., 'turn', 'new name', 'depart'
                        const modifier = bestStep.maneuver.modifier; // e.g., 'left', 'right', 'straight'
                        const name = bestStep.name || "the street";

                        if (type === 'depart') {
                            instructionText = `Head ${modifier || 'forward'} on ${name}`;
                        } else if (type === 'turn') {
                            instructionText = `Turn ${modifier} onto ${name}`;
                        } else if (type === 'new name') {
                            instructionText = `Continue onto ${name}`;
                        } else if (type === 'arrive') {
                            instructionText = `Arrive at destination`;
                        } else {
                            instructionText = `${type} ${modifier ? modifier : ''} on ${name}`;
                        }

                        // Capitalize first letter
                        instructionText = instructionText.charAt(0).toUpperCase() + instructionText.slice(1);
                    }

                    return {
                        instruction: instructionText,
                        distance: minDistance,
                        finished: false,
                        index: maneuverIndex
                    };
                };


                // --- MAP & GEO LOCATION LOGIC (Updated watchPositionSuccess) ---

                const initMap = () => {
                    // CRITICAL FIX: Wrap initialization in try/catch and call invalidateSize()
                    try {
                        map = L.map('map', { zoomControl: false }).setView([38.8893, -77.0502], 13);

                        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
                            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                            subdomains: 'abcd',
                            maxZoom: 20
                        }).addTo(map);

                        // This is a common fix for Leaflet maps inside flex containers that fail to render tiles
                        setTimeout(() => {
                            map.invalidateSize();
                            // Fetch landmarks after map is ready
                            fetchAndPinLandmarks();
                        }, 100);

                        landmarkMarkers.addTo(map);
                        L.control.zoom({ position: 'bottomright' }).addTo(map);
                        map.on('moveend', fetchAndPinLandmarks);

                        startWatchingPosition();

                    } catch (e) {
                        console.error("Map Initialization Failed:", e);
                        showMessage("Map Error", `Failed to initialize the map. Error: ${e.message}`);
                    }
                };

                const changeLocation = (lat, lng, name) => {
                    map.setView([lat, lng], 13);
                    showMessage("Location Changed", `Map centered on ${name}. Loading local historic places...`);
                };

                /**
                 * Initializes geolocation: checks for compass permission needs, gets initial fix, then starts continuous watch.
                 */
                const startWatchingPosition = () => {
                    if (watchingPosition) return;

                    const locationStatus = document.getElementById('locationStatus');
                    const locationStatusText = document.getElementById('locationStatusText');

                    // 1. Check for Compass Permission Requirement (iOS) - SHOW BUTTON in status bubble
                    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                        // iOS requires user gesture - show the button in status bubble for manual click
                        document.getElementById('enableCompassBtnInStatus').classList.remove('hidden');
                        document.getElementById('enableCompassBtn').classList.add('hidden');
                    } else {
                        // For other browsers, assume implicit permission is available
                        if (window.DeviceOrientationEvent) {
                            window.addEventListener('deviceorientation', handleCompassUpdate);
                            isCompassPermissionRequested = true;
                            // Turn indicator green since compass is available
                            document.getElementById('statusIndicator').className = 'w-2 h-2 bg-green-500 rounded-full animate-pulse flex-shrink-0';
                        }
                        document.getElementById('enableCompassBtn').classList.add('hidden');
                        document.getElementById('enableCompassBtnInStatus').classList.add('hidden');
                    }


                    if ('geolocation' in navigator) {
                        // Show status bubble immediately
                        locationStatus.classList.add('opacity-100', 'pointer-events-auto');
                        locationStatusText.textContent = "Requesting initial GPS location...";

                        // 2. Get quick initial fix (faster startup)
                        navigator.geolocation.getCurrentPosition(
                            (position) => {
                                // Use the success handler logic from watchPositionSuccess to initialize the marker and center the map right away.
                                watchPositionSuccess(position);
                                locationStatusText.textContent = "Initial location acquired. Starting continuous tracking...";

                                // 3. Start continuous watch AFTER initial fix
                                watchingPosition = true;
                                // Use high accuracy and low timeout for better real-time heading/position
                                watchId = navigator.geolocation.watchPosition(
                                    watchPositionSuccess,
                                    watchPositionError,
                                    { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
                                );
                            },
                            (error) => {
                                // If initial fix fails (e.g., permission denied, timeout), display error
                                watchPositionError(error);

                                // 4. Still start continuous watch, in case the error was temporary or a timeout
                                watchingPosition = true;
                                watchId = navigator.geolocation.watchPosition(
                                    watchPositionSuccess,
                                    watchPositionError,
                                    { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
                                );
                            },
                            { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
                        );

                    } else {
                        showMessage("Geolocation Not Supported", "Your browser does not support Geolocation, cannot track position.");
                        locationStatusText.textContent = "Geolocation unsupported.";
                    }
                };


                /**
                 * Handles successful GPS position update.
                 */
                const watchPositionSuccess = (position) => {
                    // Note: position.coords.heading is Course Over Ground (direction of movement), often null when stationary.
                    const { latitude, longitude } = position.coords;
                    const newLatLong = [latitude, longitude];

                    // Initialize or move user marker
                    if (!userMarker) {
                        userMarker = L.marker(newLatLong, { icon: userArrowIcon }).addTo(map).bindPopup("Your Location");
                        // Crucial step: Center map on user location immediately on first fix
                        map.setView(newLatLong, map.getZoom() > 14 ? map.getZoom() : 15);
                    } else {
                        userMarker.setLatLng(newLatLong);
                        // In navigation mode, pan the map to keep the user centered
                        if (currentTourStep > 0 && currentTourStep < tourRoute.length) {
                            map.panTo(newLatLong, { animate: true, duration: 1.0 });
                        }
                    }

                    // Determine what heading to display in the status bar (Compass takes priority)
                    let displayHeading = null;
                    let headingSource = "GPS";

                    if (currentSensorHeading !== null) {
                        displayHeading = currentSensorHeading;
                        headingSource = "Compass";
                    }
                    else if (position.coords.heading !== null && !isNaN(position.coords.heading)) {
                        displayHeading = position.coords.heading;
                        headingSource = "GPS";
                    }

                    // --- MODIFICATION: Display only the heading and cardinal direction ---
                    const cardinalDirection = getCardinalDirection(displayHeading);

                    const headingText = displayHeading !== null
                        ? `${cardinalDirection} (${displayHeading.toFixed(1)}°)`
                        : `Searching for heading...`;

                    // Update Status Bubble - ONLY HEADING
                    document.getElementById('locationStatusText').innerHTML = `
                <span class="text-indigo-600 font-bold">${headingText}</span>
            `;
                    // --- END MODIFICATION ---

                    // Update progressive route tracking
                    if (window.fullRouteCoordinates && window.fullRouteCoordinates.length > 0) {
                        updateProgressiveRoute(newLatLong);
                    }

                    // Handle tour progression and instruction updates
                    checkTourProgress(newLatLong);

                    // Update Panel Compass if active (even if not in roam mode, if a panel is open)
                    if (currentLandmarkLocation && displayHeading !== null) {
                        updatePanelCompass({ lat: latitude, lng: longitude }, displayHeading);
                    }
                };

                // Function to update the progressive route as user moves
                const updateProgressiveRoute = (userLatLng) => {
                    if (!window.fullRouteCoordinates || window.fullRouteCoordinates.length === 0) return;

                    // Find the closest point on the route to the user
                    let closestIndex = 0;
                    let minDistance = Infinity;

                    window.fullRouteCoordinates.forEach((coord, index) => {
                        const dist = getDistance(userLatLng[0], userLatLng[1], coord[0], coord[1]);
                        if (dist < minDistance) {
                            minDistance = dist;
                            closestIndex = index;
                        }
                    });

                    // Only update if user is reasonably close to the route (within 50 meters)
                    if (minDistance > 50) return;

                    // Get completed portion of the route (from start to user's position)
                    const completedCoords = window.fullRouteCoordinates.slice(0, closestIndex + 1);
                    const remainingCoords = window.fullRouteCoordinates.slice(closestIndex);

                    // Remove old completed path
                    if (window.completedPath) {
                        map.removeLayer(window.completedPath);
                    }

                    // Draw completed portion as thinner dotted line
                    // Draw completed path as a thinner, dotted line
                    window.completedPath = L.polyline(completedCoords, {
                        color: '#7c3aed',
                        weight: 3,
                        opacity: 0.5,
                        dashArray: '5, 10'
                    }).addTo(map);

                    // We NO LONGER draw the remaining route here.
                    // The active segment is handled by initiateRoute(), and we don't want to show future segments.
                    if (tourPath) {
                        // If tourPath is the full preview (from createTour), we might want to remove it once navigation starts.
                        // However, initiateRoute replaces tourPath with the segment route.
                        // So we just don't overwrite tourPath here with the full remaining route.
                    }
                };

                const watchPositionError = (error) => {
                    console.error('Geolocation error:', error);

                    let message = "Searching for GPS...";

                    if (error.code === error.PERMISSION_DENIED) {
                        message = "Location permission denied";
                    } else if (error.code === error.POSITION_UNAVAILABLE) {
                        message = "Location unavailable";
                    }
                    // Code 3 (TIMEOUT) is handled silently - just keep showing "Searching for GPS..."

                    document.getElementById('locationStatusText').textContent = message;
                    // Removed popup - errors are now only shown in status bubble
                };


                // --- TOUR CONFIGURATION & INITIAL ROUTE DRAWING (Unchanged) ---

                const openTourPanel = () => {
                    const panel = document.getElementById('tourPanel');
                    panel.classList.remove('translate-y-full', 'opacity-0');
                    // Populate landmark cards when opening
                    populateLandmarkCards();
                };

                const closeTourPanel = () => {
                    const panel = document.getElementById('tourPanel');
                    panel.classList.add('translate-y-full', 'opacity-0');
                };

                // --- GEMINI AI INTEGRATION ---

                const fetchFullWikipediaContent = async (pageId) => {
                    const url = `${WIKIPEDIA_API_URL}?action=query&prop=extracts&explaintext=1&pageids=${pageId}&format=json&origin=*`;
                    try {
                        const data = await fetchWithRetry(url);
                        const page = data.query?.pages?.[pageId];
                        return page?.extract || null;
                    } catch (error) {
                        console.error("Error fetching full content:", error);
                        return null;
                    }
                };

                const generateGeminiSummary = async (text, apiKey) => {
                    // Use gemini-2.5-flash-lite as the specific version
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-lite:generateContent?key=${apiKey}`;

                    const prompt = `Summarize this landmark description into a concise, engaging overview (max 3 sentences). Highlight when it was built/established if mentioned. Text: ${text.substring(0, 10000)}`; // Limit text to avoid token limits

                    const payload = {
                        contents: [{
                            parts: [{ text: prompt }]
                        }]
                    };

                    try {
                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        const data = await response.json();

                        if (data.error) {
                            throw new Error(data.error.message);
                        }

                        return data.candidates?.[0]?.content?.parts?.[0]?.text || null;
                    } catch (error) {
                        console.error("Gemini API Error:", error);
                        throw error;
                    }
                };

                // Open Knowledge Panel
                const openKnowledgePanel = async (title, markerId = 0, lat = null, lon = null) => {
                    try {
                        // Close tour panel if open
                        closeTourPanel();

                        // Set Title
                        document.getElementById('knowledgePanelTitle').textContent = title;

                        // Reset Image & Date
                        const img = document.getElementById('knowledgePanelImage');
                        const imgContainer = document.getElementById('knowledgePanelImageContainer');
                        const dateEl = document.getElementById('knowledgePanelDate');

                        img.src = '';
                        imgContainer.classList.add('hidden');
                        dateEl.textContent = '';
                        dateEl.classList.add('hidden');

                        // Show Loading in Content
                        document.getElementById('knowledgePanelDescription').innerHTML = '<p class="text-gray-500 italic">Loading details...</p>';
                        document.getElementById('knowledgePanelLink').href = '#';

                        // Store location for compass
                        // Priority:
                        // 1. Direct coordinates passed (Most reliable)
                        // 2. Lookup by title/ID (Fallback)

                        if (lat !== null && lon !== null) {
                            currentLandmarkLocation = { lat: parseFloat(lat), lon: parseFloat(lon) };
                        } else {
                            // Fallback Lookup
                            let compassTarget = tourPoints.find(p => p.title === title);
                            if (!compassTarget && markerId) {
                                compassTarget = tourPoints.find(p => p.marker && p.marker._leaflet_id == markerId);
                            }
                            if (!compassTarget) {
                                const lowerTitle = title.toLowerCase().trim();
                                compassTarget = tourPoints.find(p => p.title.toLowerCase().trim() === lowerTitle);
                            }

                            if (compassTarget) {
                                currentLandmarkLocation = { lat: compassTarget.lat, lon: compassTarget.lon };
                            } else {
                                currentLandmarkLocation = null;
                            }
                        }

                        // Force an immediate update if we have user location
                        if (currentLandmarkLocation && userMarker && currentHeading !== null) {
                            updatePanelCompass(userMarker.getLatLng(), currentHeading);
                        }

                        // Show Panel
                        const panel = document.getElementById('knowledgePanel');
                        panel.classList.remove('translate-y-full', 'opacity-0');

                        // Reset Compass
                        const arrow = document.getElementById('panelCompassArrow');
                        if (arrow) arrow.style.transform = 'rotate(0deg)';
                        const textPath = document.getElementById('compassTextPath');
                        if (textPath) textPath.textContent = '...';

                        // Find the landmark in tourPoints for other details
                        const landmark = tourPoints.find(p => p.title === title);
                        if (!landmark) {
                            console.error("Landmark not found:", title);
                            document.getElementById('knowledgePanelDescription').innerHTML = '<p class="text-red-500">Error: Landmark details not found.</p>';
                            return;
                        }

                        // Populate panel with landmark details
                        if (landmark.imageUrl) {
                            img.src = landmark.imageUrl;
                            img.alt = landmark.title;
                            imgContainer.classList.remove('hidden');
                        }
                        if (landmark.constructionDate) {
                            dateEl.textContent = landmark.constructionDate;
                            dateEl.classList.remove('hidden');
                        }
                        document.getElementById('knowledgePanelDescription').innerHTML = `<p>${landmark.extract}</p>`;
                        document.getElementById('knowledgePanelLink').href = landmark.fullUrl;

                        // Trigger AI Summary if Key Exists
                        const apiKey = localStorage.getItem('geminiApiKey') || "AIzaSyBiCOtYlbx4FyHaZVrwDo0XkBrGDMyVp7w";
                        if (apiKey) {
                            let pageId = null;
                            try {
                                const urlObj = new URL(landmark.url);
                                pageId = urlObj.searchParams.get('curid');
                            } catch (e) {
                                console.warn("Could not parse pageId from URL", landmark.url);
                            }

                            if (pageId) {
                                const loadingMsg = document.createElement('p');
                                loadingMsg.className = "text-sm text-indigo-600 font-semibold mt-2 animate-pulse";
                                loadingMsg.textContent = "✨ Generating AI Summary...";
                                document.getElementById('knowledgePanelDescription').appendChild(loadingMsg);

                                try {
                                    const fullText = await fetchFullWikipediaContent(pageId);
                                    if (fullText) {
                                        const summary = await generateGeminiSummary(fullText, apiKey);
                                        if (summary) {
                                            document.getElementById('knowledgePanelDescription').innerHTML = `<p class="font-medium text-gray-800 border-l-4 border-indigo-500 pl-3 bg-indigo-50 py-2 pr-2 rounded-r-lg mb-2">✨ ${summary}</p>`;
                                        } else {
                                            loadingMsg.remove();
                                        }
                                    } else {
                                        loadingMsg.remove();
                                    }
                                } catch (error) {
                                    console.error("AI Summary failed:", error);
                                    loadingMsg.textContent = `⚠️ Error: ${error.message}`;
                                    loadingMsg.classList.remove('animate-pulse');
                                    loadingMsg.classList.add('text-red-500');
                                }
                            }
                        } else {
                            // Optional: Add a prompt to add API key
                            const prompt = document.createElement('p');
                            prompt.className = "text-xs text-gray-400 mt-2 italic";
                            prompt.innerHTML = `Want AI summaries? <button onclick="openTourPanel(); switchTourTab('settings')" class="text-indigo-500 hover:underline">Add Gemini API Key</button>`;
                            document.getElementById('knowledgePanelDescription').appendChild(prompt);
                        }
                    } catch (error) {
                        console.error("Error opening knowledge panel:", error);
                        document.getElementById('knowledgePanelTitle').textContent = "Error";
                        document.getElementById('knowledgePanelDescription').innerHTML = `<p class="text-red-500">Failed to load details: ${error.message}</p>`;
                        document.getElementById('knowledgePanel').classList.remove('translate-y-full', 'opacity-0');
                    }
                };

                const closeKnowledgePanel = () => {
                    const panel = document.getElementById('knowledgePanel');
                    panel.classList.add('translate-y-full', 'opacity-0');
                };

                // Global state for custom tour
                let selectedLandmarks = [];

                const switchTourTab = (tab) => {
                    const distanceTab = document.getElementById('distanceTab');
                    const customTab = document.getElementById('customTab');
                    const settingsTab = document.getElementById('settingsTab');

                    const distanceBtn = document.getElementById('distanceTabBtn');
                    const customBtn = document.getElementById('customTabBtn');
                    const settingsBtn = document.getElementById('settingsTabBtn');

                    // Reset all tabs
                    distanceTab.classList.add('hidden');
                    customTab.classList.add('hidden');
                    settingsTab.classList.add('hidden');

                    distanceBtn.classList.remove('text-indigo-600', 'border-indigo-600');
                    distanceBtn.classList.add('text-gray-500', 'border-transparent');

                    customBtn.classList.remove('text-indigo-600', 'border-indigo-600');
                    customBtn.classList.add('text-gray-500', 'border-transparent');

                    settingsBtn.classList.remove('text-indigo-600', 'border-indigo-600');
                    settingsBtn.classList.add('text-gray-500', 'border-transparent');

                    // Activate selected tab
                    if (tab === 'distance') {
                        distanceTab.classList.remove('hidden');
                        distanceBtn.classList.add('text-indigo-600', 'border-indigo-600');
                        distanceBtn.classList.remove('text-gray-500', 'border-transparent');
                    } else if (tab === 'custom') {
                        customTab.classList.remove('hidden');
                        customBtn.classList.add('text-indigo-600', 'border-indigo-600');
                        customBtn.classList.remove('text-gray-500', 'border-transparent');
                        populateLandmarkCards();
                    } else if (tab === 'settings') {
                        settingsTab.classList.remove('hidden');
                        settingsBtn.classList.add('text-indigo-600', 'border-indigo-600');
                        settingsBtn.classList.remove('text-gray-500', 'border-transparent');
                        // Load saved key or default
                        const savedKey = localStorage.getItem('geminiApiKey') || "AIzaSyBiCOtYlbx4FyHaZVrwDo0XkBrGDMyVp7w";
                        document.getElementById('geminiApiKey').value = savedKey;
                    }
                };

                const saveSettings = () => {
                    const apiKey = document.getElementById('geminiApiKey').value.trim();
                    if (apiKey) {
                        localStorage.setItem('geminiApiKey', apiKey);
                        alert("Settings saved!");
                        closeTourPanel();
                    } else {
                        alert("Please enter a valid API Key.");
                    }
                };

                const populateLandmarkCards = () => {
                    const container = document.getElementById('landmarkCardsContainer');

                    if (tourPoints.length === 0) {
                        container.innerHTML = '<div class="text-center text-gray-400 py-8 w-full"><p>No landmarks found. Move the map to a different location.</p></div>';
                        return;
                    }

                    // Get reference point for sorting
                    const refLatLong = userMarker ? userMarker.getLatLng() : map.getCenter();
                    const userLat = refLatLong.lat;
                    const userLon = refLatLong.lng;

                    // Filter landmarks within 10km radius (API limit) and calculate distances
                    const TEN_KM_IN_METERS = 10000;
                    const landmarksWithDistance = tourPoints.map(point => {
                        const distanceFromUser = getDistance(userLat, userLon, point.lat, point.lon);

                        return {
                            ...point,
                            distanceFromUser
                        };
                    }).filter(point => point.distanceFromUser <= TEN_KM_IN_METERS);

                    // Sort by proximity to current location
                    const sortedLandmarks = landmarksWithDistance.sort((a, b) => {
                        return a.distanceFromUser - b.distanceFromUser;
                    });

                    container.innerHTML = '';

                    if (sortedLandmarks.length === 0) {
                        container.innerHTML = '<div class="text-center text-gray-400 py-8 w-full"><p>No landmarks within 10km (6.2 mi). Move the map to a different location.</p></div>';
                        return;
                    }

                    sortedLandmarks.forEach((point, index) => {
                        const card = document.createElement('div');
                        card.className = 'flex-shrink-0 w-40 bg-white border-2 border-gray-200 rounded-xl overflow-hidden snap-start transition-all duration-200 hover:shadow-lg';
                        card.id = `landmark-card-${point.title.replace(/\s/g, '-')}`;

                        const isSelected = selectedLandmarks.some(l => l.pageid === point.pageid);
                        if (isSelected) {
                            card.classList.add('border-indigo-500', 'bg-indigo-50');
                        }

                        // Calculate distance in miles for display
                        const distanceMiles = (point.distanceFromUser / 1609.34).toFixed(1);

                        const imageHtml = point.imageUrl
                            ? `<img src="${point.imageUrl}" alt="${point.title}" class="h-24 w-full object-cover">`
                            : `<div class="h-24 bg-gradient-to-br from-indigo-400 to-purple-500 flex items-center justify-center text-white text-3xl font-bold">${point.title.charAt(0)}</div>`;

                        card.innerHTML = `
                    ${imageHtml}
                    <div class="p-2">
                        <h4 class="font-semibold text-xs text-gray-800 mb-1 line-clamp-2 h-8">${point.title}</h4>
                        <p class="text-xs text-gray-500 mb-1">${distanceMiles} mi</p>
                        <button onclick="toggleLandmarkSelection(${point.pageid})"
                            id="btn-${index}"
                            class="${isSelected ? 'bg-red-500 hover:bg-red-600' : 'bg-indigo-600 hover:bg-indigo-700'} text-white text-xs font-bold py-1.5 px-2 rounded-lg w-full transition">
                            ${isSelected ? 'Remove' : 'Add'}
                        </button>
                    </div>
                `;

                        container.appendChild(card);
                    });
                };

                const toggleLandmarkSelection = (pageid) => {
                    // Convert pageid to string for comparison if needed, though usually int
                    const existingIndex = selectedLandmarks.findIndex(l => l.pageid === pageid);

                    if (existingIndex >= 0) {
                        // Remove from selection
                        selectedLandmarks.splice(existingIndex, 1);
                    } else {
                        // Add to selection - find the full point data from tourPoints
                        const point = tourPoints.find(p => p.pageid === pageid);
                        if (point) {
                            selectedLandmarks.push(point);
                        } else {
                            console.error("Could not find point with pageid:", pageid);
                        }
                    }

                    updateSelectedCount();
                    populateLandmarkCards();
                };

                const clearSelectedLandmarks = () => {
                    selectedLandmarks = [];
                    updateSelectedCount();
                    populateLandmarkCards();
                };

                const updateSelectedCount = () => {
                    document.getElementById('selectedCount').textContent = selectedLandmarks.length;
                    const btn = document.getElementById('createCustomTourBtn');
                    if (selectedLandmarks.length >= 2) {
                        btn.disabled = false;
                    } else {
                        btn.disabled = true;
                    }
                };

                // Wrapper function to handle async createCustomTour
                const handleCreateCustomTour = async () => {
                    console.log("handleCreateCustomTour called");
                    closeTourPanel();
                    await createCustomTour();
                };

                const createCustomTour = async () => {
                    console.log("createCustomTour function started");

                    if (selectedLandmarks.length < 1) {
                        showMessage("Not Enough Stops", "Please select at least 1 landmark for your custom tour.");
                        return;
                    }

                    try {
                        // Show loading overlay
                        const loadingOverlay = document.getElementById('loadingOverlay');
                        const loadingText = document.getElementById('loadingText');
                        const loadingProgress = document.getElementById('loadingProgress');
                        loadingOverlay.classList.remove('hidden');

                        const refLatLong = userMarker ? userMarker.getLatLng() : map.getCenter();

                        const startPoint = {
                            lat: refLatLong.lat,
                            lon: refLatLong.lng,
                            title: "Start Point",
                            isWiki: false
                        };

                        // Optimize the order of selected landmarks
                        const optimizedLandmarks = optimizeRouteOrder(startPoint, selectedLandmarks);

                        // Create route: Start -> Optimized Landmarks -> Start
                        tourRoute = [startPoint, ...optimizedLandmarks, startPoint];
                        currentTourStep = 0;

                        // Fetch actual walking routes for all segments
                        const allRouteCoordinates = [];
                        const segmentData = []; // Store data for each segment
                        let totalDistance = 0;
                        let totalDuration = 0;
                        let successfulRoutes = 0;

                        console.log(`Fetching routes for ${tourRoute.length - 1} segments...`);

                        for (let i = 0; i < tourRoute.length - 1; i++) {
                            const start = tourRoute[i];
                            const end = tourRoute[i + 1];

                            // Update loading text and progress
                            loadingText.textContent = `Fetching route ${i + 1} of ${tourRoute.length - 1}...`;
                            loadingProgress.style.width = `${((i + 1) / (tourRoute.length - 1)) * 100}%`;

                            console.log(`Fetching route ${i + 1}/${tourRoute.length - 1}: ${start.title} -> ${end.title}`);
                            const routeData = await fetchWalkingRoute(start.lat, start.lon, end.lat, end.lon);

                            if (routeData && routeData.path && routeData.path.length > 0) {
                                // Add the route coordinates
                                console.log(`✓ Route ${i + 1} fetched: ${routeData.path.length} points, ${(routeData.distance / 1609.34).toFixed(2)} mi`);

                                const segmentStart = allRouteCoordinates.length;
                                allRouteCoordinates.push(...routeData.path);

                                segmentData.push({
                                    start: segmentStart,
                                    end: allRouteCoordinates.length - 1,
                                    distance: routeData.distance,
                                    midpoint: routeData.path[Math.floor(routeData.path.length / 2)]
                                });

                                totalDuration += routeData.duration;
                                successfulRoutes++;
                            } else {
                                // Fallback to straight line if routing fails
                                console.warn(`✗ Route ${i + 1} failed, using straight line`);
                                allRouteCoordinates.push([start.lat, start.lon], [end.lat, end.lon]);

                                // Calculate straight-line distance for fallback
                                const fallbackDist = getDistance(start.lat, start.lon, end.lat, end.lon);
                                totalDistance += fallbackDist;
                                // Estimate duration (walking speed ~1.4 m/s)
                                totalDuration += fallbackDist / 1.4;

                                segmentData.push({
                                    start: allRouteCoordinates.length - 2,
                                    end: allRouteCoordinates.length - 1,
                                    distance: fallbackDist,
                                    midpoint: [(start.lat + end.lat) / 2, (start.lon + end.lon) / 2]
                                });
                            }
                        }

                        console.log(`Route fetching complete: ${successfulRoutes}/${tourRoute.length - 1} successful`);
                        console.log(`Total coordinates: ${allRouteCoordinates.length}`);

                        // Store the full route coordinates globally for progressive tracking
                        window.fullRouteCoordinates = allRouteCoordinates;
                        window.completedRouteCoordinates = [];

                        // Draw the complete walking route as a dashed line (preview mode)
                        if (tourPath) map.removeLayer(tourPath);
                        tourPath = L.polyline(allRouteCoordinates, {
                            color: '#7c3aed',  // Purple color
                            weight: 4,
                            opacity: 0.8,
                            dashArray: '15, 15', // Larger dash pattern
                            renderer: L.svg() // Force SVG renderer
                        }).addTo(map);

                        // Initialize completed path layer (will be updated as user moves)
                        if (window.completedPath) map.removeLayer(window.completedPath);
                        window.completedPath = null;

                        // Initialize distance markers array
                        if (!window.distanceMarkers) window.distanceMarkers = [];

                        // Add distance labels for each segment
                        segmentData.forEach((segment, index) => {
                            const distanceMiles = (segment.distance / 1609.34).toFixed(1);
                            const midpoint = segment.midpoint;

                            if (midpoint) {
                                const marker = L.marker([midpoint[0], midpoint[1]], {
                                    icon: L.divIcon({
                                        className: 'distance-label',
                                        html: `<div style="background: white; padding: 4px 8px; border-radius: 12px; border: 2px solid #7c3aed; font-size: 11px; font-weight: bold; color: #7c3aed; white-space: nowrap; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">${distanceMiles} mi</div>`,
                                        iconSize: [60, 24]
                                    })
                                }).addTo(map);
                                window.distanceMarkers.push(marker);
                            }
                        });

                        // Display total distance and duration in navigation panel
                        // Walking speed: 2.5 mph = 0.04167 miles per minute = 24 minutes per mile
                        const distanceMiles = (totalDistance / 1609.34).toFixed(1);
                        const durationMinutes = Math.round((totalDistance / 1609.34) * 24); // 24 min per mile at 2.5mph

                        if (totalDistance === 0) {
                            alert(`Debug: Total Distance is 0! Routes: ${successfulRoutes}/${tourRoute.length - 1}. Start: ${startPoint.lat},${startPoint.lon}`);
                        }

                        document.getElementById('tourDistance').textContent = `${distanceMiles} mi`;
                        document.getElementById('tourDuration').textContent = `~${durationMinutes} min`;
                        document.getElementById('tourStats').classList.remove('hidden');
                        document.getElementById('tourStats').style.display = 'flex'; // Force display

                        // Hide loading overlay
                        loadingOverlay.classList.add('hidden');

                        document.getElementById('navigationPanel').classList.remove('translate-y-full', 'opacity-0');

                        // CHANGE BUTTON TO STOP TOUR
                        const tourBtn = document.getElementById('startTourButton');
                        tourBtn.textContent = "Stop Tour";
                        tourBtn.classList.remove('bg-emerald-500', 'hover:bg-emerald-600');
                        tourBtn.classList.add('bg-red-500', 'hover:bg-red-600');
                        tourBtn.onclick = endTour;

                        updateNavigationPanel();
                        map.fitBounds(tourPath.getBounds(), { padding: [50, 50] });
                    } catch (e) {
                        console.error("Create Custom Tour Error:", e);
                        document.getElementById('loadingOverlay').classList.add('hidden');
                        showMessage("Tour Error", "Failed to create custom tour: " + e.message);
                    }
                };


                const fetchWikipediaLandmarks = async (lat, lon) => {
                    // Deep Scan Strategy:
                    // 1. Fetch 500 raw items using list=geosearch (lightweight).
                    // 2. Fetch details (props) for ALL of them in batches of 50.
                    // 3. Apply Smart Filter to the full dataset.

                    const radius = 10000; // 10km
                    const limit = 500; // Max for geosearch

                    // Step 1: Get IDs and coords
                    const listUrl = `${WIKIPEDIA_API_URL}?action=query&list=geosearch&gscoord=${lat}|${lon}&gsradius=${radius}&gslimit=${limit}&format=json&origin=*`;

                    let rawItems = [];
                    try {
                        console.log("Step 1: Fetching 500 raw items...");
                        const data = await fetchWithRetry(listUrl);
                        if (data.query && data.query.geosearch) {
                            rawItems = data.query.geosearch;
                        }
                    } catch (e) {
                        console.error("Geosearch failed", e);
                        return [];
                    }

                    if (rawItems.length === 0) {
                        console.warn("No raw items found.");
                        return [];
                    }

                    console.log(`Step 1 Complete: Found ${rawItems.length} raw items.`);

                    // Create a map for distance lookup
                    const distMap = new Map(rawItems.map(i => [i.pageid, i.dist]));

                    // Step 2: Batch fetch details
                    // Chunk into 50s
                    const chunks = [];
                    for (let i = 0; i < rawItems.length; i += 50) {
                        chunks.push(rawItems.slice(i, i + 50));
                    }

                    const buildingKeywords = [
                        'building', 'structure', 'house', 'tower', 'church', 'cathedral', 'museum',
                        'station', 'school', 'library', 'hotel', 'theater', 'monument', 'statue',
                        'park', 'bridge', 'skyscraper', 'temple', 'synagogue', 'mosque', 'palace',
                        'castle', 'fort', 'stadium', 'arena', 'university', 'college', 'hall'
                    ];

                    let validLandmarks = [];

                    console.log(`Step 2: Fetching details for ${chunks.length} batches...`);

                    // Process batches in parallel
                    const batchPromises = chunks.map(async (chunk) => {
                        const pageIds = chunk.map(p => p.pageid).join('|');
                        const detailsUrl = `${WIKIPEDIA_API_URL}?action=query&prop=coordinates|pageimages|extracts|pageprops|info&pageids=${pageIds}&pithumbsize=200&exintro=1&explaintext=1&inprop=url&format=json&origin=*`;

                        try {
                            const data = await fetchWithRetry(detailsUrl);
                            const pages = data.query?.pages || {};

                            Object.values(pages).forEach(p => {
                                const title = p.title.toLowerCase();
                                const desc = p.pageprops?.['wikibase-shortdesc']?.toLowerCase() || "";

                                // Smart Filter: Check if title OR description contains any building keyword
                                const isBuilding = buildingKeywords.some(kw => title.includes(kw) || desc.includes(kw));

                                if (isBuilding && p.coordinates) {
                                    validLandmarks.push({
                                        pageid: p.pageid,
                                        title: p.title,
                                        lat: p.coordinates[0].lat,
                                        lon: p.coordinates[0].lon,
                                        dist: distMap.get(p.pageid) || 0,
                                        imageUrl: p.thumbnail ? p.thumbnail.source : null,
                                        extract: p.extract || "No description available.",
                                        url: p.fullurl || `https://en.wikipedia.org/?curid=${p.pageid}`,
                                        constructionDate: p.pageprops?.['wikibase-shortdesc'] || null,
                                        wikibaseItem: p.pageprops?.wikibase_item
                                    });
                                }
                            });
                        } catch (e) {
                            console.warn("Batch details fetch failed", e);
                        }
                    });

                    await Promise.all(batchPromises);

                    console.log(`Step 2 Complete: ${validLandmarks.length} landmarks passed the Smart Filter.`);
                    return validLandmarks;
                };

                const pinLandmark = (lat, lon, title, url, imageUrl, details = {}) => {
                    const marker = L.marker([lat, lon], { icon: landmarkIcon }).addTo(landmarkMarkers);

                    let popupHtml = ``;
                    if (imageUrl) {
                        popupHtml += `<div class="mb-2 w-full h-32 bg-gray-100 rounded-lg overflow-hidden">
                    <img src="${imageUrl}" alt="${title}" class="w-full h-full object-cover">
                </div>`;
                    }

                    popupHtml += `
                <div class="font-bold text-indigo-700 mb-2">${title}</div>
                <button onclick="openKnowledgePanel('${title.replace(/'/g, "\\'")}', ${marker._leaflet_id}, ${lat}, ${lon})"
                    class="w-full bg-indigo-600 hover:bg-indigo-700 text-white text-sm font-bold py-2 px-4 rounded-lg transition">
                    Learn More
                </button>
            `;

                    marker.bindPopup(popupHtml);
                    tourPoints.push({
                        lat,
                        lon,
                        title,
                        isWiki: true,
                        url,
                        marker,
                        imageUrl,
                        extract: details.extract || "No description available.",
                        constructionDate: details.constructionDate || null,
                        fullUrl: details.url || url,
                        pageid: details.pageid || null
                    });
                };

                // Global Set to track loaded landmarks
                const loadedLandmarkIds = new Set();

                const fetchAndPinLandmarks = async () => {
                    if (isFetching) return;
                    isFetching = true;

                    // Silent update - no loading overlay
                    try {
                        const center = map.getCenter();
                        const landmarks = await fetchWikipediaLandmarks(center.lat, center.lng);

                        if (landmarks.length > 0) {
                            let newCount = 0;
                            landmarks.forEach(p => {
                                // Only pin if not already loaded
                                if (!loadedLandmarkIds.has(p.pageid)) {
                                    loadedLandmarkIds.add(p.pageid);
                                    pinLandmark(p.lat, p.lon, p.title, p.url, p.imageUrl, {
                                        extract: p.extract,
                                        constructionDate: p.constructionDate,
                                        url: p.url,
                                        pageid: p.pageid
                                    });
                                    newCount++;
                                }
                            });

                            if (newCount > 0) {
                                console.log(`Discovery Complete: Added ${newCount} new historic places.`);
                            } else {
                                console.log("No new buildings found in this area.");
                            }
                        } else {
                            console.log("No buildings found nearby.");
                        }

                    } catch (error) {
                        console.error("Error in fetchAndPinLandmarks:", error);
                        // Silent fail for better UX on map move
                    } finally {
                        isFetching = false;
                    }
                };


                // Wrapper function to handle async createTour
                const handleCreateTour = async () => {
                    console.log("handleCreateTour called");
                    closeTourPanel();
                    await createTour(true);
                };

                /**
                 * Optimizes the order of stops using a Nearest Neighbor algorithm.
                 * @param {Object} start - The starting point {lat, lon}
                 * @param {Array} stops - Array of stop objects {lat, lon, ...}
                 * @returns {Array} - Reordered array of stops
                 */
                const optimizeRouteOrder = (start, stops) => {
                    const unvisited = [...stops];
                    const optimized = [];
                    let currentLocation = start;

                    while (unvisited.length > 0) {
                        let nearestIndex = -1;
                        let minDist = Infinity;

                        for (let i = 0; i < unvisited.length; i++) {
                            const dist = getDistance(currentLocation.lat, currentLocation.lon, unvisited[i].lat, unvisited[i].lon);
                            if (dist < minDist) {
                                minDist = dist;
                                nearestIndex = i;
                            }
                        }

                        if (nearestIndex !== -1) {
                            const nextStop = unvisited.splice(nearestIndex, 1)[0];
                            optimized.push(nextStop);
                            currentLocation = nextStop;
                        }
                    }
                    return optimized;
                };

                const createTour = async (reset = false) => {
                    console.log("createTour function started");
                    const maxDistanceMiles = parseFloat(document.getElementById('tourDistance').value);
                    const maxDistanceMeters = maxDistanceMiles * 1609.34;

                    if (tourPoints.length < 2) {
                        document.getElementById('tourStatus').textContent = 'Error: Not enough landmarks loaded.';
                        showMessage("Tour Failed: No Pins", `Only ${tourPoints.length} landmarks found on the map. Please ensure the map is centered over a major city.`);
                        return;
                    }

                    const refLatLong = userMarker ? userMarker.getLatLng() : map.getCenter();

                    const startPoint = {
                        lat: refLatLong.lat,
                        lon: refLatLong.lng,
                        title: userMarker ? "Your Start Location" : "Map Center Start",
                        isWiki: false,
                        url: null
                    };

                    let potentialStops = tourPoints.filter(p => {
                        const distance = getDistance(startPoint.lat, startPoint.lon, p.lat, p.lon);
                        return distance <= maxDistanceMeters;
                    }).map(p => ({
                        ...p,
                        distance: getDistance(startPoint.lat, startPoint.lon, p.lat, p.lon)
                    }));

                    if (potentialStops.length < 2) {
                        document.getElementById('tourStatus').textContent = `Error: Only ${potentialStops.length} pins available locally.`;
                        showMessage("Tour Failed: Pins Too Far", `Only ${potentialStops.length} landmarks found within ${maxDistanceMiles} miles of the starting point. Try increasing the Max Tour Distance in this panel.`);
                        return;
                    }

                    potentialStops.sort((a, b) => a.distance - b.distance);

                    // Optimize the order of the top 5 closest stops
                    const topStops = potentialStops.slice(0, 5);
                    const optimizedStops = optimizeRouteOrder(startPoint, topStops);

                    // Create the route: Start -> Optimized Stops -> Return to Start
                    const returnToStart = { ...startPoint, title: "Return to Start" };
                    tourRoute = [startPoint, ...optimizedStops, returnToStart];
                    currentTourStep = 0;
                    currentManeuverIndex = -1;

                    try {
                        // Show loading message
                        document.getElementById('tourStatus').textContent = 'Calculating walking routes...';

                        // Fetch actual walking routes for all segments
                        const allRouteCoordinates = [];
                        let totalDistance = 0;
                        let totalDuration = 0;
                        let successfulRoutes = 0;

                        console.log(`Fetching routes for ${tourRoute.length - 1} segments...`);

                        for (let i = 0; i < tourRoute.length - 1; i++) {
                            const start = tourRoute[i];
                            const end = tourRoute[i + 1];

                            console.log(`Fetching route ${i + 1}/${tourRoute.length - 1}: ${start.title} -> ${end.title}`);
                            const routeData = await fetchWalkingRoute(start.lat, start.lon, end.lat, end.lon);

                            if (routeData && routeData.path && routeData.path.length > 0) {
                                // Add the route coordinates
                                console.log(`✓ Route ${i + 1} fetched: ${routeData.path.length} points, ${(routeData.distance / 1609.34).toFixed(2)} mi`);
                                allRouteCoordinates.push(...routeData.path);
                                totalDistance += routeData.distance;
                                totalDuration += routeData.duration;
                                successfulRoutes++;
                            } else {
                                // Fallback to straight line if routing fails
                                console.warn(`✗ Route ${i + 1} failed, using straight line`);
                                allRouteCoordinates.push([start.lat, start.lon], [end.lat, end.lon]);

                                // Calculate straight-line distance for fallback
                                const fallbackDist = getDistance(start.lat, start.lon, end.lat, end.lon);
                                totalDistance += fallbackDist;
                                // Estimate duration (walking speed ~1.4 m/s)
                                totalDuration += fallbackDist / 1.4;
                            }
                        }

                        console.log(`Route fetching complete: ${successfulRoutes}/${tourRoute.length - 1} successful`);
                        console.log(`Total coordinates: ${allRouteCoordinates.length}`);

                        // Store the full route coordinates globally for progressive tracking
                        window.fullRouteCoordinates = allRouteCoordinates;
                        window.completedRouteCoordinates = [];

                        // Draw the complete walking route as a dashed line (preview mode)
                        if (tourPath) map.removeLayer(tourPath);
                        tourPath = L.polyline(allRouteCoordinates, {
                            color: '#7c3aed',  // Purple color
                            weight: 4,
                            opacity: 0.8,
                            dashArray: '15, 15', // Larger dash pattern
                            renderer: L.svg() // Force SVG renderer
                        }).addTo(map);

                        // Initialize completed path layer (will be updated as user moves)
                        if (window.completedPath) map.removeLayer(window.completedPath);
                        window.completedPath = null;

                        // Display total distance and duration in navigation panel
                        // Walking speed: 2.5 mph = 24 minutes per mile
                        const distanceMiles = (totalDistance / 1609.34).toFixed(1);
                        const durationMinutes = Math.round((totalDistance / 1609.34) * 24); // 24 min per mile at 2.5mph

                        if (totalDistance === 0) {
                            alert(`Debug: Total Distance is 0! Routes: ${successfulRoutes}/${tourRoute.length - 1}. Start: ${startPoint.lat},${startPoint.lon}`);
                        }

                        document.getElementById('tourDistance').textContent = `${distanceMiles} mi`;
                        document.getElementById('tourDuration').textContent = `~${durationMinutes} min`;
                        document.getElementById('tourStats').classList.remove('hidden');
                        document.getElementById('tourStats').style.display = 'flex'; // Force display

                        document.getElementById('navigationPanel').classList.remove('translate-y-full', 'opacity-0');

                        // CHANGE BUTTON TO STOP TOUR
                        const tourBtn = document.getElementById('startTourButton');
                        tourBtn.textContent = "Stop Tour";
                        tourBtn.classList.remove('bg-emerald-500', 'hover:bg-emerald-600');
                        tourBtn.classList.add('bg-red-500', 'hover:bg-red-600');
                        tourBtn.onclick = endTour;

                        updateNavigationPanel();
                        map.fitBounds(tourPath.getBounds(), { padding: [50, 50] });
                    } catch (e) {
                        console.error("Create Tour Error:", e);
                        showMessage("Tour Error", "Failed to create tour: " + e.message);
                    }
                };


                /**
                 * Fetches the detailed walking route to the current destination and updates the map.
                 */
                const initiateRoute = async () => {
                    if (currentTourStep <= 0 || currentTourStep >= tourRoute.length) return;

                    const endPoint = tourRoute[currentTourStep]; // Target

                    const userLatLong = userMarker ? userMarker.getLatLng() : map.getCenter();

                    // Use current user location as the actual start of the segment
                    const currentStart = { lat: userLatLong.lat, lon: userLatLong.lng };

                    // Hide stats to show more map
                    document.getElementById('tourStats').classList.add('hidden');
                    document.getElementById('tourStats').style.display = 'none'; // Force hide

                    // Hide next button until close to destination
                    const navBtn = document.getElementById('navActionButton');
                    navBtn.textContent = "Calculating Route...";
                    navBtn.disabled = true;
                    navBtn.classList.add('hidden');

                    const routeData = await fetchWalkingRoute(currentStart.lat, currentStart.lon, endPoint.lat, endPoint.lon);

                    // Clear old path
                    if (tourPath) map.removeLayer(tourPath);

                    if (routeData) {
                        // Store the steps in the target object
                        tourRoute[currentTourStep].steps = routeData.steps;
                        currentManeuverIndex = 0; // Reset maneuver tracking

                        // Draw the detailed OSRM route
                        tourPath = L.polyline(routeData.path, {
                            color: '#7c3aed',  // Purple to match preview
                            weight: 6,
                            opacity: 0.9,
                            lineJoin: 'round'
                        }).addTo(map);

                        // Estimate time and distance
                        const distanceKm = (routeData.distance / 1000).toFixed(2);
                        const durationMinutes = Math.ceil(routeData.duration / 60);

                        // Update the instruction with overall segment data
                        let nextText = `Walk ${distanceKm} km (approx. ${durationMinutes} min). <br>`;
                        if (endPoint.isWiki) {
                            nextText += `Destination: <span class="font-bold">${endPoint.title}</span>. <a href="${endPoint.url}" target="_blank" class="text-white underline hover:text-green-200">(Wiki Info)</a>`;
                        } else {
                            nextText += `Destination: <span class="font-bold">${endPoint.title}</span>.`;
                        }

                        document.getElementById('nextLandmarkInfo').innerHTML = nextText;

                        // Set high zoom level for GPS mode
                        map.setView(userLatLong, 18, { animate: true, duration: 1.5 });
                    } else {
                        // Fallback: draw a simple line
                        const simplePath = [
                            L.latLng(currentStart.lat, currentStart.lon),
                            L.latLng(endPoint.lat, endPoint.lon)
                        ];
                        tourPath = L.polyline(simplePath, {
                            color: '#f87171',
                            weight: 4,
                            opacity: 0.7
                        }).addTo(map);

                        document.getElementById('nextLandmarkInfo').innerHTML = `
                    Routing failed, follow the straight line to: 
                    <span class="font-bold">${endPoint.title}</span>.
                `;
                        map.setView(userLatLong, 18, { animate: true, duration: 1.5 });
                    }

                    document.getElementById('navActionButton').textContent = "Next Stop";
                    document.getElementById('navActionButton').disabled = true;
                }

                const updateNavigationPanel = () => {
                    if (!tourRoute || tourRoute.length <= 1) return;

                    const totalStops = tourRoute.length - 1;
                    document.getElementById('navStepCounter').textContent = `${currentTourStep}/${totalStops}`;

                    if (currentTourStep === 0) {
                        // Pre-Navigation State
                        const nextStop = tourRoute[1];
                        document.getElementById('currentNavInstruction').textContent = "Tour Ready: Conceptual Route";
                        document.getElementById('nextLandmarkInfo').innerHTML = `The dashed line shows the approximate path. Press <span class="font-bold">'Start Navigation'</span> to get the walking route to: <span class="font-bold">${nextStop.title}</span>.`;
                        const navBtn = document.getElementById('navActionButton');
                        navBtn.textContent = "Start Navigation";
                        navBtn.disabled = false;
                        navBtn.classList.remove('hidden');

                    } else if (currentTourStep < tourRoute.length) {
                        // Mid-tour steps - Trigger detailed route fetch
                        const target = tourRoute[currentTourStep];
                        document.getElementById('currentNavInstruction').textContent = `Navigating to Stop ${currentTourStep}/${totalStops}: ${target.title}`;

                        // Only initiate route if steps haven't been loaded yet for this segment
                        if (!target.steps) {
                            initiateRoute();
                        }

                    } else {
                        // Tour finished
                        document.getElementById('currentNavInstruction').textContent = "Tour Completed!";
                        document.getElementById('nextLandmarkInfo').textContent = "You've visited all designated historic points!";
                        document.getElementById('navActionButton').textContent = "End Tour";
                        document.getElementById('navActionButton').disabled = false;
                    }
                }

                const nextSegment = () => {
                    if (currentTourStep < tourRoute.length - 1) {
                        // Advance to the next landmark
                        currentTourStep++;
                        // Reset maneuver index for the new segment
                        currentManeuverIndex = 0;
                        updateNavigationPanel();
                    } else if (currentTourStep === 0) {
                        // Initial click on "Start Navigation"
                        currentTourStep = 1;
                        updateNavigationPanel(); // This triggers initiateRoute()
                    }
                    else if (currentTourStep === tourRoute.length - 1) {
                        endTour();
                    }
                }

                const endTour = () => {
                    // End Tour logic - remove all route layers
                    if (tourPath) map.removeLayer(tourPath);
                    if (window.completedPath) map.removeLayer(window.completedPath);

                    // Remove all distance label markers
                    if (window.distanceMarkers && window.distanceMarkers.length > 0) {
                        window.distanceMarkers.forEach(marker => map.removeLayer(marker));
                        window.distanceMarkers = [];
                    }

                    tourRoute = null;
                    currentTourStep = 0;
                    currentManeuverIndex = -1;
                    window.fullRouteCoordinates = [];
                    window.completedRouteCoordinates = [];

                    document.getElementById('navigationPanel').classList.add('translate-y-full', 'opacity-0');
                    document.getElementById('tourStats').classList.add('hidden');
                    document.getElementById('tourStats').style.display = 'none'; // Force hide

                    // RESET BUTTON TO START TOUR
                    const tourBtn = document.getElementById('startTourButton');
                    tourBtn.textContent = "Start Tour";
                    tourBtn.classList.remove('bg-red-500', 'hover:bg-red-600');
                    tourBtn.classList.add('bg-emerald-500', 'hover:bg-emerald-600');
                    tourBtn.onclick = openTourPanel;
                }

                const checkTourProgress = (userLatLong) => {
                    // Only perform GPS checks if we are actively navigating to a landmark
                    if (!tourRoute || currentTourStep < 1 || currentTourStep >= tourRoute.length || !tourRoute[currentTourStep].steps) {
                        if (currentTourStep > 0 && userMarker) {
                            // Pan map to keep user in center during navigation
                            map.panTo(userMarker.getLatLng(), { animate: true, duration: 1.0 });
                        }
                        return;
                    }

                    const target = tourRoute[currentTourStep];
                    const userLat = userLatLong[0];
                    const userLon = userLatLong[1];

                    const distanceToDestination = getDistance(userLat, userLon, target.lat, target.lon);
                    const arrivalThreshold = 30; // 30 meters ≈ 100 feet

                    // --- 1. Check for Destination Arrival ---
                    if (distanceToDestination < arrivalThreshold) {
                        const navBtn = document.getElementById('navActionButton');
                        navBtn.classList.remove('hidden');
                        navBtn.disabled = false;
                        document.getElementById('currentNavInstruction').innerHTML = `<span class="text-yellow-200 font-bold">ARRIVED:</span> ${target.title}`;
                        document.getElementById('nextLandmarkInfo').textContent = `You have reached this location. Press 'Next Stop' to continue the tour.`;
                        return;
                    }

                    // --- 2. Get Next Maneuver Instruction ---
                    const maneuverResult = findNextManeuver(userLat, userLon, target.steps);

                    // Update the Panel with GPS Instructions
                    if (!maneuverResult.finished) {
                        const distanceFeet = (maneuverResult.distance * 3.28084).toFixed(0); // Convert to feet

                        document.getElementById('currentNavInstruction').innerHTML = `
                    <span class="font-bold text-lg">${maneuverResult.instruction}</span>
                `;

                        document.getElementById('nextLandmarkInfo').innerHTML = `
                    in <span class="font-bold text-xl text-yellow-300">${distanceFeet} ft</span>
                `;

                        // If the user has progressed past the last known maneuver, update the index.
                        if (maneuverResult.index > currentManeuverIndex) {
                            currentManeuverIndex = maneuverResult.index;
                        }
                    } else {
                        // Final stretch before arrival
                        const distanceMeters = distanceToDestination.toFixed(0);
                        document.getElementById('currentNavInstruction').innerHTML = `Final Stretch: Proceed to ${target.title}`;
                        document.getElementById('nextLandmarkInfo').textContent = `Distance remaining: ${distanceMeters} meters.`;
                    }

                    // --- 3. Keep User Centered and Zoomed ---
                    map.panTo(userMarker.getLatLng(), { animate: true, duration: 1.0 });
                    if (map.getZoom() < 18) map.setZoom(18);
                }

                document.addEventListener('DOMContentLoaded', initMap);
            </script>
</body>

</html>

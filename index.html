<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Historic Landmark Map with Real-Time GeoSearch and Navigation</title>
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>

    <!-- Leaflet Polyline Decoders/Encoders - required for OSRM routes -->
    <script src="https://unpkg.com/@mapbox/polyline@1.0.0/src/polyline.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fc;
        }

        .leaflet-container {
            font-family: 'Inter', sans-serif;
            position: relative !important;
            z-index: 1 !important;
        }

        #map {
            position: relative !important;
            z-index: 1 !important;
        }

        .leaflet-default-icon-path {
            /* Standard marker path, kept for fallback */
            background-image: url('https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png');
        }

        input[type=range] {
            -webkit-appearance: none;
            background: transparent;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #a5b4fc;
            border-radius: 2px;
        }

        /* User Marker Arrow (The blue circle container) */
        .user-arrow-marker {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px !important;
            height: 40px !important;
            margin-left: -20px !important;
            margin-top: -20px !important;
            position: relative;
            /* Needed for absolute positioning of the triangle */
            transition: transform 0.3s ease-out;
            /* Smooth marker transition */
        }

        /* The Rotating White Triangle Indicator */
        #userDirectionArrow {
            position: absolute;
            /* Pivot point: slightly below the geometric center to place the tip visually correct */
            transform-origin: 50% 75%;

            /* Create the triangle shape using CSS borders */
            width: 0;
            height: 0;
            border-style: solid;
            border-width: 0 6px 14px 6px;
            /* 14px height, 12px base width */
            border-color: transparent transparent #ffffff transparent;
            /* White tip pointing up */

            /* Adjust position to center the pivot point */
            margin-top: -10px;
            /* REDUCED TRANSITION TIME FOR SMOOTH COMPASS MOVEMENT */
            transition: transform 0.05s linear;
        }

        /* Message Box for custom alerts */
        #messageBox {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 5000;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        #messageBox.visible {
            opacity: 1;
            pointer-events: auto;
        }

        /* HIDE LEAFLET ZOOM CONTROLS FOR A CLEANER UI */
        .leaflet-control-zoom {
            display: none !important;
        }

        /* Icon styling for navigation instructions */
        .nav-icon {
            display: inline-block;
            width: 1.5rem;
            height: 1.5rem;
            margin-right: 0.5rem;
            vertical-align: middle;
        }
    </style>
</head>

<body class="flex flex-col h-screen overflow-hidden">

    <!-- Message Box (Custom Alert) -->
    <div id="messageBox" class="p-6 bg-white rounded-xl shadow-2xl max-w-sm w-full">
        <h3 id="messageTitle" class="text-lg font-bold mb-2 text-gray-800">Alert</h3>
        <p id="messageText" class="text-sm text-gray-600 mb-4">Content</p>
        <button onclick="document.getElementById('messageBox').classList.remove('visible')"
            class="w-full bg-indigo-600 text-white py-2 rounded-lg hover:bg-indigo-700">
            OK
        </button>
    </div>

    <!-- Header (Compacted) -->
    <header class="bg-blue-900 shadow-xl z-[4000] p-3 flex flex-col gap-3 flex-none fixed top-0 left-0 right-0"
        style="position: fixed !important; top: 0 !important;">

        <!-- Title and Controls Row 1 -->
        <div class="flex flex-col md:flex-row items-center justify-between gap-3">
            <div class="text-center md:text-left">
                <h1 class="text-xl font-bold text-white leading-tight">Historic Places Explorer <span
                        class="bg-yellow-400 text-blue-900 text-xs font-bold px-2 py-1 rounded-md ml-2">v4.4</span></h1>
                <p class="text-indigo-200 text-xs hidden sm:block">Real-time Wikipedia Landmarks & Tour Guide</p>
            </div>

            <!-- Controls Group Row 1 -->
            <div class="flex flex-wrap items-center justify-center gap-3">

                <!-- Location Dropdown -->
                <div class="relative">
                    <button onclick="document.getElementById('locationDropdown').classList.toggle('hidden')"
                        class="bg-indigo-500 hover:bg-indigo-400 text-white text-xs font-bold py-2 px-3 rounded-lg shadow transition flex items-center gap-1">
                        <span>Location</span>
                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7">
                            </path>
                        </svg>
                    </button>
                    <!-- Dropdown Menu -->
                    <div id="locationDropdown"
                        class="hidden absolute top-full right-0 mt-2 w-48 bg-white rounded-lg shadow-xl py-2 z-50 border border-gray-100">
                        <button
                            onclick="changeLocation(38.8893, -77.0502, 'Washington D.C.'); document.getElementById('locationDropdown').classList.add('hidden')"
                            class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-indigo-50">Washington
                            D.C.</button>
                        <button
                            onclick="changeLocation(40.7580, -73.9855, 'Midtown Manhattan'); document.getElementById('locationDropdown').classList.add('hidden')"
                            class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-indigo-50">Midtown
                            Manhattan</button>
                        <button
                            onclick="changeLocation(51.5074, 0.1278, 'London'); document.getElementById('locationDropdown').classList.add('hidden')"
                            class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-indigo-50">London,
                            UK</button>
                    </div>
                </div>

                <!-- Enable Compass Button (FALLBACK ONLY - Hidden initially) -->
                <button id="enableCompassBtn" onclick="handleCompassPermissionRequest()"
                    class="bg-yellow-500 hover:bg-yellow-600 text-gray-900 text-xs font-bold py-2 px-3 rounded-lg shadow transition whitespace-nowrap hidden">
                    Enable Compass
                </button>

                <!-- Tour Button -->
                <button id="startTourButton" onclick="openTourPanel()"
                    class="bg-emerald-500 hover:bg-emerald-600 text-white text-xs font-bold py-2 px-3 rounded-lg shadow transition whitespace-nowrap">
                    Start Tour
                </button>
            </div>
        </div>

        <!-- Filter Row 2 (Full Width) -->
        <div class="flex items-center gap-3 w-full max-w-4xl mx-auto">

            <!-- Category Filter Input -->
            <div class="flex-grow bg-indigo-700 rounded-lg p-2 flex items-center gap-2 w-full">
                <label for="categoryFilter"
                    class="text-white text-xs font-medium whitespace-nowrap hidden sm:block">Filter by Keyword:</label>
                <input type="text" id="categoryFilter" placeholder="e.g., house, museum, park (5km Search Radius)"
                    onchange="fetchAndPinLandmarks()"
                    class="w-full p-1 bg-indigo-800 text-white placeholder-indigo-300 text-xs rounded-md focus:ring-indigo-300 focus:border-indigo-300">
            </div>
        </div>
    </header>


    <!-- Tour Panel (Slide-up Card with Tabs) -->
    <div id="tourPanel" style="padding-bottom: calc(env(safe-area-inset-bottom, 20px) + 1rem);"
        class="fixed inset-x-0 bottom-0 bg-white text-gray-800 p-3 sm:p-4 shadow-2xl rounded-t-3xl transition-all duration-300 transform translate-y-full opacity-0 z-[5000] max-h-[65vh] overflow-y-auto">
        <div class="max-w-4xl mx-auto flex flex-col">

            <!-- Header with Close Button -->
            <div class="flex justify-between items-center mb-2">
                <h3 class="text-xl font-bold text-indigo-700">Configure Tour</h3>
                <button onclick="closeTourPanel()" class="text-gray-400 hover:text-gray-600 transition">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12">
                        </path>
                    </svg>
                </button>
            </div>

            <!-- Tab Navigation -->
            <div class="flex gap-2 mb-3 border-b border-gray-200">
                <button id="distanceTabBtn" onclick="switchTourTab('distance')"
                    class="px-4 py-2 font-semibold text-indigo-600 border-b-2 border-indigo-600 transition">
                    Distance-Based
                </button>
                <button id="customTabBtn" onclick="switchTourTab('custom')"
                    class="px-4 py-2 font-semibold text-gray-500 border-b-2 border-transparent hover:text-indigo-600 transition">
                    Custom Tour
                </button>
            </div>

            <!-- Distance-Based Tour Tab -->
            <div id="distanceTab" class="tour-tab">
                <div class="mb-4">
                    <label for="tourDistance" class="block text-sm font-semibold text-gray-700 mb-2">
                        Max Tour Distance (Miles)
                    </label>
                    <input type="number" id="tourDistance" min="1" max="15" value="5" step="0.5"
                        class="block w-full rounded-xl border-2 border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 text-lg p-3">
                </div>
                <p class="text-sm text-gray-500 mb-4">Finds closest landmarks and optimizes for distance.</p>
                <button onclick="handleCreateTour()"
                    class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-xl transition duration-200 shadow-lg">
                    Create Tour
                </button>
            </div>

            <!-- Custom Tour Tab -->
            <div id="customTab" class="tour-tab hidden">
                <p class="text-xs text-gray-600 mb-2">Select landmarks to visit:</p>

                <!-- Selected Count -->
                <div class="mb-2 flex items-center gap-2">
                    <span class="text-sm font-semibold text-indigo-600">Selected: <span
                            id="selectedCount">0</span></span>
                    <button onclick="clearSelectedLandmarks()"
                        class="text-xs text-red-500 hover:text-red-700 underline">Clear All</button>
                </div>

                <!-- Horizontal Scrollable Landmark Cards -->
                <div id="landmarkCardsContainer"
                    class="flex gap-2 overflow-x-auto pb-2 mb-2 snap-x snap-mandatory scrollbar-hide">
                    <!-- Cards will be dynamically inserted here -->
                    <div class="text-center text-gray-400 py-8 w-full">
                        <p>Loading landmarks...</p>
                    </div>
                </div>

                <!-- Status Text -->
                <p id="tourStatus" class="text-xs text-gray-500 mb-2">Creates an optimized route through your selected
                    stops.</p>

                <!-- Create Custom Tour Button -->
                <button onclick="handleCreateCustomTour()"
                    class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-xl transition duration-200 shadow-lg disabled:bg-gray-400 disabled:cursor-not-allowed"
                    id="createCustomTourBtn" disabled>
                    Create Custom Tour
                </button>
            </div>
        </div>
    </div>

    <style>
        /* Hide scrollbar for Chrome, Safari and Opera */
        .scrollbar-hide::-webkit-scrollbar {
            display: none;
        }

        /* Hide scrollbar for IE, Edge and Firefox */
        .scrollbar-hide {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
    </style>

    <!-- Map Container -->
    <div id="map" class="w-full bg-gray-200"
        style="position: fixed !important; top: 150px; left: 0; right: 0; bottom: 0; z-index: 1 !important;"></div>

    <!-- Loading Overlay -->
    <div id="loadingOverlay"
        class="hidden fixed inset-0 bg-black/50 backdrop-blur-sm z-[9000] flex items-center justify-center">
        <div class="bg-white rounded-2xl p-8 shadow-2xl flex flex-col items-center gap-4 max-w-sm mx-4">
            <div class="relative w-16 h-16">
                <div class="absolute inset-0 border-4 border-indigo-200 rounded-full"></div>
                <div class="absolute inset-0 border-4 border-indigo-600 rounded-full border-t-transparent animate-spin">
                </div>
            </div>
            <h3 class="text-xl font-bold text-gray-800">Generating Route</h3>
            <p id="loadingText" class="text-sm text-gray-600 text-center">Calculating optimal walking paths...</p>
            <div class="w-full bg-gray-200 rounded-full h-2 overflow-hidden">
                <div id="loadingProgress" class="bg-indigo-600 h-full transition-all duration-300" style="width: 0%">
                </div>
            </div>
        </div>
    </div>

    <!-- Location Status Bubble (REPOSITIONED & Compacted) -->
    <div id="locationStatus"
        class="fixed top-[10.5rem] sm:top-[8rem] left-1/2 transform -translate-x-1/2 bg-white/90 backdrop-blur-sm px-4 py-2 rounded-full shadow-xl z-[6000] flex items-center gap-3 transition-opacity duration-500 w-11/12 max-w-3xl border border-gray-200">
        <div id="statusIndicator" class="w-2 h-2 bg-red-500 rounded-full animate-pulse flex-shrink-0"></div>
        <span class="text-sm font-medium text-gray-800 whitespace-nowrap overflow-hidden text-ellipsis flex-grow"
            id="locationStatusText">Locating...</span>
        <!-- Enable Compass Button (shown when needed) -->
        <button id="enableCompassBtnInStatus" onclick="handleCompassPermissionRequest()"
            class="hidden bg-yellow-500 hover:bg-yellow-600 text-gray-900 text-xs font-bold py-1 px-3 rounded-lg shadow transition whitespace-nowrap">
            Enable Compass
        </button>
    </div>

    <!-- NAVIGATION PANEL (Green Bar - Fixed to Bottom) -->
    <div id="navigationPanel" style="padding-bottom: calc(env(safe-area-inset-bottom, 20px) + 2rem);"
        class="fixed inset-x-0 bottom-0 bg-green-600 text-white p-4 sm:p-6 shadow-2xl rounded-t-3xl transition-all duration-300 transform translate-y-full opacity-0 z-[5000] min-h-[12rem] h-auto">
        <div class="max-w-xl mx-auto flex flex-col h-full">

            <!-- Current Step Display -->
            <div class="flex items-start space-x-3 mb-2">
                <svg id="navInstructionIcon" class="w-6 h-6 flex-shrink-0 mt-1" fill="currentColor" viewBox="0 0 24 24">
                    <path
                        d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17.93c-3.95-.49-7-3.41-7-7.38 0-.47.05-.93.14-1.39l5.86 5.86v2.91zm5.93-5.07l-5.86-5.86c.46-.09.92-.14 1.39-.14 3.97 0 6.89 3.05 7.38 7zm-5.93-10.79l5.86 5.86c-.46.09-.92-.14-1.39-.14-3.97 0-6.89-3.05-7.38-7zm-5.93 5.07l5.86 5.86c-.46.09-.92-.14-1.39-.14-3.97 0-6.89-3.05-7.38-7z" />
                </svg>
                <h2 id="currentNavInstruction" class="text-xl sm:text-2xl font-semibold leading-tight">Waiting for
                    Tour...</h2>
            </div>

            <!-- Next Steps & Progress -->
            <div class="flex justify-between items-end mt-1 mb-2 border-t border-green-500 pt-3">
                <p id="nextLandmarkInfo" class="text-sm opacity-90 leading-relaxed max-w-[70%]">Next: Please start a
                    tour using the button above.</p>
                <p id="navStepCounter" class="text-sm font-medium opacity-80 flex-shrink-0 ml-4">0/0</p>
            </div>

            <!-- Tour Statistics -->
            <div id="tourStats"
                class="hidden mb-4 bg-green-700/50 rounded-xl p-3 flex items-center justify-around gap-2">
                <div class="flex items-center gap-2">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7">
                        </path>
                    </svg>
                    <span id="tourDistance" class="text-sm font-semibold">0.0 mi</span>
                </div>
                <div class="w-px h-6 bg-green-400/50"></div>
                <div class="flex items-center gap-2">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                    <span id="tourDuration" class="text-sm font-semibold">0 min</span>
                </div>
            </div>

            <!-- Action Button -->
            <div class="flex-grow flex items-end">
                <button id="navActionButton" onclick="nextSegment()"
                    class="w-full bg-white text-green-600 font-bold py-3 px-6 rounded-xl hover:bg-gray-100 transition duration-200 shadow-lg">
                    Next Stop
                </button>
            </div>
        </div>
    </div>


    <script>
        // Global State
        let map;
        let userMarker = null;
        let landmarkMarkers = new L.LayerGroup();
        let tourRoute = null; // Array of {lat, lon, title, steps, ...} objects
        let tourPath = null; // The Leaflet Polyline/Route object
        let tourPoints = []; // Populated by GeoSearch
        const WIKIPEDIA_API_URL = 'https://en.wikipedia.org/w/api.php';
        // Using OSRM Public Server for routing
        const OSRM_API_URL = 'https://router.project-osrm.org/route/v1/foot/';
        let isFetching = false; // Prevent multiple concurrent fetches

        let currentTourStep = 0; // 0 = ready to start, 1+ = navigating to this stop index
        let watchingPosition = false;
        let watchId = null;
        let currentManeuverIndex = -1; // Index of the next maneuver in the OSRM steps array

        // NEW: State for compass permission AND the live heading data
        let isCompassPermissionRequested = false;
        let currentSensorHeading = null; // Stores live heading from deviceorientation sensor

        // CONSTANT: Fixed search radius in kilometers (5 miles is approx 8.04672 km, sticking to 5km for precision)
        const FIXED_SEARCH_RADIUS_KM = 5;

        // Custom Marker Icon for User Location (Simple Arrow)
        const userArrowIcon = L.divIcon({
            className: 'user-arrow-marker bg-indigo-600 rounded-full border-4 border-white shadow-xl',
            iconSize: [40, 40],
            // HTML for the CSS triangle indicator
            html: '<div id="userDirectionArrow"></div>',
            popupAnchor: [0, -10]
        });

        // Landmark Marker Icon (A simple red dot for historic sites)
        const landmarkIcon = L.divIcon({
            className: 'bg-red-600 rounded-full border-2 border-white shadow-lg',
            iconSize: [12, 12]
        });

        // Utility: Custom Alert/Modal Box
        const showMessage = (title, text) => {
            document.getElementById('messageTitle').textContent = title;
            document.getElementById('messageText').textContent = text;
            document.getElementById('messageBox').classList.add('visible');
        };

        // Utility: Exponential Backoff for Fetch
        const fetchWithRetry = async (url, options = {}, retries = 3) => {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return await response.json();
                } catch (error) {
                    if (i < retries - 1) {
                        const delay = Math.pow(2, i) * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                    } else {
                        throw error;
                    }
                }
            }
        };

        // Utility: Haversine distance calculation in meters
        const getDistance = (lat1, lon1, lat2, lon2) => {
            const R = 6371e3; // metres
            const φ1 = lat1 * Math.PI / 180;
            const φ2 = lat2 * Math.PI / 180;
            const Δφ = (lat2 - lat1) * Math.PI / 180;
            const Δλ = (lon2 - lon1) * Math.PI / 180;

            const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                Math.cos(φ1) * Math.cos(φ2) *
                Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            return R * c; // Distance in meters
        }

        // --- UTILITY FUNCTION: CARDINAL DIRECTION CONVERSION ---
        /**
         * Converts a numerical heading (0-360 degrees) into a cardinal direction string (e.g., "N", "SW").
         * @param {number} degrees - The heading in degrees.
         * @returns {string} The cardinal direction.
         */
        function getCardinalDirection(degrees) {
            if (degrees === null || typeof degrees === 'undefined' || isNaN(degrees)) {
                return 'N/A';
            }

            // Normalize degrees to 0-360
            degrees = (degrees % 360 + 360) % 360;

            const directions = ["N", "NNE", "NE", "ENE", "E", "ESE", "SE", "SSE", "S", "SSW", "SW", "WSW", "W", "WNW", "NW", "NNW"];
            // Each direction covers 360 / 16 = 22.5 degrees.
            // Half a sector is 22.5 / 2 = 11.25 degrees.
            // We shift the heading by half a sector and divide by the sector size.
            const index = Math.floor((degrees + 11.25) / 22.5);

            return directions[index % 16];
        }
        // --- END UTILITY FUNCTION ---


        // --- UPDATED: SENSOR DATA HANDLER (Now updates DOM directly for smoothness) ---
        /**
         * Listens to deviceorientation event and updates the global heading variable 
         * AND applies rotation to the arrow for smooth, high-frequency updates.
         */
        const handleCompassUpdate = (event) => {
            let magneticHeading = null;
            const arrow = document.getElementById('userDirectionArrow');
            const locationStatusText = document.getElementById('locationStatusText');


            // 1. Check for webkitCompassHeading (best accuracy on iOS Safari)
            if (event.webkitCompassHeading !== undefined && event.webkitCompassHeading !== null) {
                magneticHeading = event.webkitCompassHeading;
            }
            // 2. Fallback to standard alpha (needs adjustment based on screen orientation)
            else if (event.alpha !== undefined && event.alpha !== null) {
                let alpha = event.alpha;

                // Calculate magnetic heading (360 - alpha) and normalize
                magneticHeading = (360 - alpha + 360) % 360;
            }

            if (magneticHeading !== null) {
                currentSensorHeading = magneticHeading;

                // Apply rotation to the arrow
                const pointerRotation = magneticHeading;
                const cardinal = getCardinalDirection(magneticHeading);

                arrow.style.transform = `rotate(${pointerRotation}deg)`;

                // --- MODIFICATION: Simplified status text to only show heading ---
                const headingText = `${cardinal} (${magneticHeading.toFixed(1)}°)`;

                if (locationStatusText) {
                    // Update the status text with the current heading only
                    locationStatusText.innerHTML = `<span class="text-indigo-600 font-bold">${headingText}</span>`;
                }
                // --- END MODIFICATION ---
            }
        }

        // --- UPDATED: COMPASS PERMISSION LOGIC ---

        /**
         * Requests permission to access Device Orientation data (compass/sensors).
         */
        const handleCompassPermissionRequest = () => {
            const btn = document.getElementById('enableCompassBtn');
            const btnInStatus = document.getElementById('enableCompassBtnInStatus');
            const statusIndicator = document.getElementById('statusIndicator');

            btn.classList.add('hidden'); // Hide header button while requesting
            btnInStatus.classList.add('hidden'); // Hide status button while requesting

            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(permissionState => {
                        if (permissionState === 'granted') {
                            isCompassPermissionRequested = true;
                            // SUCCESS: Attach the listener
                            window.addEventListener('deviceorientation', handleCompassUpdate);
                            // Turn indicator green
                            statusIndicator.className = 'w-2 h-2 bg-green-500 rounded-full animate-pulse flex-shrink-0';
                        } else {
                            // DENIED: Show the button as a fallback/retry option
                            isCompassPermissionRequested = false;
                            btnInStatus.classList.remove('hidden');
                            showMessage("Compass Access Needed", "Heading data was denied. Click 'Enable Compass' to try again.");
                        }
                    })
                    .catch(error => {
                        console.error('Error requesting device orientation permission:', error);
                        isCompassPermissionRequested = false;
                        btnInStatus.classList.remove('hidden'); // Show status button on error
                    });
            } else {
                // Non-iOS or older browsers: assume permission is implicit.
                // Attach listener immediately.
                if (window.DeviceOrientationEvent) {
                    window.addEventListener('deviceorientation', handleCompassUpdate);
                    isCompassPermissionRequested = true;
                    // Turn indicator green
                    statusIndicator.className = 'w-2 h-2 bg-green-500 rounded-full animate-pulse flex-shrink-0';
                }
                btn.classList.add('hidden');
                btnInStatus.classList.add('hidden');
            }
        };

        // --- ROUTING & NAVIGATION FUNCTIONS (Unchanged) ---
        // ... (fetchWalkingRoute, findNextManeuver unchanged) ...

        /**
         * Fetches a detailed walking route with steps from OSRM.
         */
        const fetchWalkingRoute = async (startLat, startLon, endLat, endLon) => {
            // OSRM expects coordinates in [lon, lat] format
            const coordinates = `${startLon},${startLat};${endLon},${endLat}`;
            // Request polyline geometry AND steps
            const url = `${OSRM_API_URL}${coordinates}?geometries=polyline&steps=true&overview=full`;

            console.log(`Fetching route from OSRM: ${url}`);

            try {
                const data = await fetchWithRetry(url);
                console.log("OSRM response received:", data);

                if (data.routes && data.routes.length > 0) {
                    const route = data.routes[0];
                    const leg = route.legs[0];

                    const polylineString = route.geometry;
                    console.log("Polyline string:", polylineString);

                    const decodedPath = polyline.decode(polylineString);
                    console.log("Decoded path length:", decodedPath.length);

                    return {
                        path: decodedPath,
                        distance: route.distance,
                        duration: route.duration,
                        steps: leg.steps // The turn-by-turn instructions
                    };
                } else {
                    console.error("No routes in OSRM response");
                    throw new Error("No route found by OSRM.");
                }
            } catch (error) {
                console.error("OSRM Routing Error:", error);
                // Silently return null - caller will handle fallback
                return null;
            }
        }

        /**
         * Finds the next maneuver instruction the user needs to follow.
         */
        const findNextManeuver = (userLat, userLon, targetSteps) => {
            if (!targetSteps || targetSteps.length === 0) {
                return { instruction: "Continue to your destination.", distance: 0, finished: true };
            }

            let bestStep = targetSteps[targetSteps.length - 1]; // Default to the last step (arrival)
            let minDistance = Infinity;
            let maneuverIndex = -1;

            // Iterate through steps, looking for the *closest* maneuver point that hasn't been passed
            // The OSRM steps contain the maneuver location in the 'location' array (lon, lat)
            for (let i = 0; i < targetSteps.length; i++) {
                const step = targetSteps[i];
                // Step location is [lon, lat]
                const stepLon = step.maneuver.location[0];
                const stepLat = step.maneuver.location[1];

                const distanceToStep = getDistance(userLat, userLon, stepLat, stepLon);

                // If the user is close enough (e.g., within 20m) and we haven't checked this one, 
                // we treat the next one as the current target.
                if (distanceToStep > 20) {
                    // Since we iterate sequentially, the first step we find that is > 20m away 
                    // from the maneuver point is the 'next' one to aim for.
                    if (distanceToStep < minDistance) {
                        minDistance = distanceToStep;
                        bestStep = step;
                        maneuverIndex = i;
                        break; // Found the target maneuver
                    }
                }
            }

            // Handle arrival (last step)
            if (maneuverIndex === -1 || maneuverIndex === targetSteps.length - 1) {
                return { instruction: "Arriving at your destination!", distance: getDistance(userLat, userLon, tourRoute[currentTourStep].lat, tourRoute[currentTourStep].lon), finished: true, index: targetSteps.length - 1 };
            }

            // Return the instruction and the distance to the maneuver location
            return {
                instruction: bestStep.maneuver.instruction,
                distance: minDistance,
                finished: false,
                index: maneuverIndex
            };
        };


        // --- MAP & GEO LOCATION LOGIC (Updated watchPositionSuccess) ---

        const initMap = () => {
            // CRITICAL FIX: Wrap initialization in try/catch and call invalidateSize()
            try {
                map = L.map('map', { zoomControl: false }).setView([38.8893, -77.0502], 13);

                L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                    subdomains: 'abcd',
                    maxZoom: 20
                }).addTo(map);

                // This is a common fix for Leaflet maps inside flex containers that fail to render tiles
                setTimeout(() => {
                    map.invalidateSize();
                    // Fetch landmarks after map is ready
                    fetchAndPinLandmarks();
                }, 100);

                landmarkMarkers.addTo(map);
                L.control.zoom({ position: 'bottomright' }).addTo(map);
                map.on('moveend', fetchAndPinLandmarks);

                startWatchingPosition();

            } catch (e) {
                console.error("Map Initialization Failed:", e);
                showMessage("Map Error", `Failed to initialize the map. Error: ${e.message}`);
            }
        };

        const changeLocation = (lat, lng, name) => {
            map.setView([lat, lng], 13);
            showMessage("Location Changed", `Map centered on ${name}. Loading local historic places...`);
        };

        /**
         * Initializes geolocation: checks for compass permission needs, gets initial fix, then starts continuous watch.
         */
        const startWatchingPosition = () => {
            if (watchingPosition) return;

            const locationStatus = document.getElementById('locationStatus');
            const locationStatusText = document.getElementById('locationStatusText');

            // 1. Check for Compass Permission Requirement (iOS) - SHOW BUTTON in status bubble
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                // iOS requires user gesture - show the button in status bubble for manual click
                document.getElementById('enableCompassBtnInStatus').classList.remove('hidden');
                document.getElementById('enableCompassBtn').classList.add('hidden');
            } else {
                // For other browsers, assume implicit permission is available
                if (window.DeviceOrientationEvent) {
                    window.addEventListener('deviceorientation', handleCompassUpdate);
                    isCompassPermissionRequested = true;
                    // Turn indicator green since compass is available
                    document.getElementById('statusIndicator').className = 'w-2 h-2 bg-green-500 rounded-full animate-pulse flex-shrink-0';
                }
                document.getElementById('enableCompassBtn').classList.add('hidden');
                document.getElementById('enableCompassBtnInStatus').classList.add('hidden');
            }


            if ('geolocation' in navigator) {
                // Show status bubble immediately
                locationStatus.classList.add('opacity-100', 'pointer-events-auto');
                locationStatusText.textContent = "Requesting initial GPS location...";

                // 2. Get quick initial fix (faster startup)
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        // Use the success handler logic from watchPositionSuccess to initialize the marker and center the map right away.
                        watchPositionSuccess(position);
                        locationStatusText.textContent = "Initial location acquired. Starting continuous tracking...";

                        // 3. Start continuous watch AFTER initial fix
                        watchingPosition = true;
                        // Use high accuracy and low timeout for better real-time heading/position
                        watchId = navigator.geolocation.watchPosition(
                            watchPositionSuccess,
                            watchPositionError,
                            { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
                        );
                    },
                    (error) => {
                        // If initial fix fails (e.g., permission denied, timeout), display error
                        watchPositionError(error);

                        // 4. Still start continuous watch, in case the error was temporary or a timeout
                        watchingPosition = true;
                        watchId = navigator.geolocation.watchPosition(
                            watchPositionSuccess,
                            watchPositionError,
                            { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
                        );
                    },
                    { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
                );

            } else {
                showMessage("Geolocation Not Supported", "Your browser does not support Geolocation, cannot track position.");
                locationStatusText.textContent = "Geolocation unsupported.";
            }
        };


        /**
         * Handles successful GPS position update.
         */
        const watchPositionSuccess = (position) => {
            // Note: position.coords.heading is Course Over Ground (direction of movement), often null when stationary.
            const { latitude, longitude } = position.coords;
            const newLatLong = [latitude, longitude];

            // Initialize or move user marker
            if (!userMarker) {
                userMarker = L.marker(newLatLong, { icon: userArrowIcon }).addTo(map).bindPopup("Your Location");
                // Crucial step: Center map on user location immediately on first fix
                map.setView(newLatLong, map.getZoom() > 14 ? map.getZoom() : 15);
            } else {
                userMarker.setLatLng(newLatLong);
                // In navigation mode, pan the map to keep the user centered
                if (currentTourStep > 0 && currentTourStep < tourRoute.length) {
                    map.panTo(newLatLong, { animate: true, duration: 1.0 });
                }
            }

            // Determine what heading to display in the status bar (Compass takes priority)
            let displayHeading = null;
            let headingSource = "GPS";

            if (currentSensorHeading !== null) {
                displayHeading = currentSensorHeading;
                headingSource = "Compass";
            }
            else if (position.coords.heading !== null && !isNaN(position.coords.heading)) {
                displayHeading = position.coords.heading;
                headingSource = "GPS";
            }

            // --- MODIFICATION: Display only the heading and cardinal direction ---
            const cardinalDirection = getCardinalDirection(displayHeading);

            const headingText = displayHeading !== null
                ? `${cardinalDirection} (${displayHeading.toFixed(1)}°)`
                : `Searching for heading...`;

            // Update Status Bubble - ONLY HEADING
            document.getElementById('locationStatusText').innerHTML = `
                <span class="text-indigo-600 font-bold">${headingText}</span>
            `;
            // --- END MODIFICATION ---

            // Update progressive route tracking
            if (window.fullRouteCoordinates && window.fullRouteCoordinates.length > 0) {
                updateProgressiveRoute(newLatLong);
            }

            // Handle tour progression and instruction updates
            checkTourProgress(newLatLong);
        };

        // Function to update the progressive route as user moves
        const updateProgressiveRoute = (userLatLng) => {
            if (!window.fullRouteCoordinates || window.fullRouteCoordinates.length === 0) return;

            // Find the closest point on the route to the user
            let closestIndex = 0;
            let minDistance = Infinity;

            window.fullRouteCoordinates.forEach((coord, index) => {
                const dist = getDistance(userLatLng[0], userLatLng[1], coord[0], coord[1]);
                if (dist < minDistance) {
                    minDistance = dist;
                    closestIndex = index;
                }
            });

            // Only update if user is reasonably close to the route (within 50 meters)
            if (minDistance > 50) return;

            // Get completed portion of the route (from start to user's position)
            const completedCoords = window.fullRouteCoordinates.slice(0, closestIndex + 1);
            const remainingCoords = window.fullRouteCoordinates.slice(closestIndex);

            // Remove old completed path
            if (window.completedPath) {
                map.removeLayer(window.completedPath);
            }

            // Draw completed portion as thinner dotted line
            if (completedCoords.length > 1) {
                window.completedPath = L.polyline(completedCoords, {
                    color: '#7c3aed',  // Same purple
                    weight: 2,  // Thinner
                    opacity: 0.5,
                    dashArray: '5, 5'  // Dotted
                }).addTo(map);
            }

            // Update main route to show only remaining portion
            if (tourPath) {
                map.removeLayer(tourPath);
            }
            if (remainingCoords.length > 1) {
                tourPath = L.polyline(remainingCoords, {
                    color: '#7c3aed',  // Purple
                    weight: 4,  // Solid thick
                    opacity: 0.9
                }).addTo(map);
            }
        };

        const watchPositionError = (error) => {
            console.error('Geolocation error:', error);

            let message = "Searching for GPS...";

            if (error.code === error.PERMISSION_DENIED) {
                message = "Location permission denied";
            } else if (error.code === error.POSITION_UNAVAILABLE) {
                message = "Location unavailable";
            }
            // Code 3 (TIMEOUT) is handled silently - just keep showing "Searching for GPS..."

            document.getElementById('locationStatusText').textContent = message;
            // Removed popup - errors are now only shown in status bubble
        };


        // --- TOUR CONFIGURATION & INITIAL ROUTE DRAWING (Unchanged) ---

        const openTourPanel = () => {
            const panel = document.getElementById('tourPanel');
            panel.classList.remove('translate-y-full', 'opacity-0');
            // Populate landmark cards when opening
            populateLandmarkCards();
        };

        const closeTourPanel = () => {
            const panel = document.getElementById('tourPanel');
            panel.classList.add('translate-y-full', 'opacity-0');
        };

        // Global state for custom tour
        let selectedLandmarks = [];

        const switchTourTab = (tab) => {
            const distanceTab = document.getElementById('distanceTab');
            const customTab = document.getElementById('customTab');
            const distanceBtn = document.getElementById('distanceTabBtn');
            const customBtn = document.getElementById('customTabBtn');

            if (tab === 'distance') {
                distanceTab.classList.remove('hidden');
                customTab.classList.add('hidden');
                distanceBtn.classList.add('text-indigo-600', 'border-indigo-600');
                distanceBtn.classList.remove('text-gray-500', 'border-transparent');
                customBtn.classList.remove('text-indigo-600', 'border-indigo-600');
                customBtn.classList.add('text-gray-500', 'border-transparent');
            } else {
                distanceTab.classList.add('hidden');
                customTab.classList.remove('hidden');
                customBtn.classList.add('text-indigo-600', 'border-indigo-600');
                customBtn.classList.remove('text-gray-500', 'border-transparent');
                distanceBtn.classList.remove('text-indigo-600', 'border-indigo-600');
                distanceBtn.classList.add('text-gray-500', 'border-transparent');
                populateLandmarkCards();
            }
        };

        const populateLandmarkCards = () => {
            const container = document.getElementById('landmarkCardsContainer');

            if (tourPoints.length === 0) {
                container.innerHTML = '<div class="text-center text-gray-400 py-8 w-full"><p>No landmarks found. Move the map to a different location.</p></div>';
                return;
            }

            // Get reference point for sorting
            const refLatLong = userMarker ? userMarker.getLatLng() : map.getCenter();
            const userLat = refLatLong.lat;
            const userLon = refLatLong.lng;

            // Filter landmarks within 5 mile radius and calculate distances
            const FIVE_MILES_IN_METERS = 5 * 1609.34;
            const landmarksWithDistance = tourPoints.map(point => {
                const distanceFromUser = getDistance(userLat, userLon, point.lat, point.lon);

                return {
                    ...point,
                    distanceFromUser
                };
            }).filter(point => point.distanceFromUser <= FIVE_MILES_IN_METERS);

            // Sort by proximity to current location
            const sortedLandmarks = landmarksWithDistance.sort((a, b) => {
                return a.distanceFromUser - b.distanceFromUser;
            });

            container.innerHTML = '';

            if (sortedLandmarks.length === 0) {
                container.innerHTML = '<div class="text-center text-gray-400 py-8 w-full"><p>No landmarks within 5 miles. Move the map to a different location.</p></div>';
                return;
            }

            sortedLandmarks.forEach((point, index) => {
                const card = document.createElement('div');
                card.className = 'flex-shrink-0 w-40 bg-white border-2 border-gray-200 rounded-xl overflow-hidden snap-start transition-all duration-200 hover:shadow-lg';
                card.id = `landmark-card-${point.title.replace(/\s/g, '-')}`;

                const isSelected = selectedLandmarks.some(l => l.title === point.title);
                if (isSelected) {
                    card.classList.add('border-indigo-500', 'bg-indigo-50');
                }

                // Calculate distance in miles for display
                const distanceMiles = (point.distanceFromUser / 1609.34).toFixed(1);

                card.innerHTML = `
                    <div class="h-24 bg-gradient-to-br from-indigo-400 to-purple-500 flex items-center justify-center text-white text-3xl font-bold">
                        ${point.title.charAt(0)}
                    </div>
                    <div class="p-2">
                        <h4 class="font-semibold text-xs text-gray-800 mb-1 line-clamp-2 h-8">${point.title}</h4>
                        <p class="text-xs text-gray-500 mb-1">${distanceMiles} mi</p>
                        <button onclick="toggleLandmarkSelection('${point.title.replace(/'/g, "\\'")}', ${point.lat}, ${point.lon})" 
                            id="btn-${index}"
                            class="${isSelected ? 'bg-red-500 hover:bg-red-600' : 'bg-indigo-600 hover:bg-indigo-700'} text-white text-xs font-bold py-1.5 px-2 rounded-lg w-full transition">
                            ${isSelected ? 'Remove' : 'Add'}
                        </button>
                    </div>
                `;

                container.appendChild(card);
            });
        };

        const toggleLandmarkSelection = (title, lat, lon) => {
            const existingIndex = selectedLandmarks.findIndex(l => l.title === title);

            if (existingIndex >= 0) {
                // Remove from selection
                selectedLandmarks.splice(existingIndex, 1);
            } else {
                // Add to selection - find the full point data from tourPoints
                const point = tourPoints.find(p => p.title === title);
                if (point) {
                    selectedLandmarks.push(point);
                }
            }

            updateSelectedCount();
            populateLandmarkCards();
        };

        const clearSelectedLandmarks = () => {
            selectedLandmarks = [];
            updateSelectedCount();
            populateLandmarkCards();
        };

        const updateSelectedCount = () => {
            document.getElementById('selectedCount').textContent = selectedLandmarks.length;
            const btn = document.getElementById('createCustomTourBtn');
            if (selectedLandmarks.length >= 2) {
                btn.disabled = false;
            } else {
                btn.disabled = true;
            }
        };

        // Wrapper function to handle async createCustomTour
        const handleCreateCustomTour = async () => {
            console.log("handleCreateCustomTour called");
            closeTourPanel();
            await createCustomTour();
        };

        const createCustomTour = async () => {
            console.log("createCustomTour function started");

            if (selectedLandmarks.length < 2) {
                showMessage("Not Enough Stops", "Please select at least 2 landmarks for your custom tour.");
                return;
            }

            try {
                // Show loading overlay
                const loadingOverlay = document.getElementById('loadingOverlay');
                const loadingText = document.getElementById('loadingText');
                const loadingProgress = document.getElementById('loadingProgress');
                loadingOverlay.classList.remove('hidden');

                const refLatLong = userMarker ? userMarker.getLatLng() : map.getCenter();

                const startPoint = {
                    lat: refLatLong.lat,
                    lon: refLatLong.lng,
                    title: "Start Point",
                    isWiki: false
                };

                // Create route: Start -> Selected Landmarks -> Start
                tourRoute = [startPoint, ...selectedLandmarks, startPoint];
                currentTourStep = 0;

                // Fetch actual walking routes for all segments
                const allRouteCoordinates = [];
                const segmentData = []; // Store data for each segment
                let totalDistance = 0;
                let totalDuration = 0;
                let successfulRoutes = 0;

                console.log(`Fetching routes for ${tourRoute.length - 1} segments...`);

                for (let i = 0; i < tourRoute.length - 1; i++) {
                    const start = tourRoute[i];
                    const end = tourRoute[i + 1];

                    // Update loading text and progress
                    loadingText.textContent = `Fetching route ${i + 1} of ${tourRoute.length - 1}...`;
                    loadingProgress.style.width = `${((i + 1) / (tourRoute.length - 1)) * 100}%`;

                    console.log(`Fetching route ${i + 1}/${tourRoute.length - 1}: ${start.title} -> ${end.title}`);
                    const routeData = await fetchWalkingRoute(start.lat, start.lon, end.lat, end.lon);

                    if (routeData && routeData.path && routeData.path.length > 0) {
                        // Add the route coordinates
                        console.log(`✓ Route ${i + 1} fetched: ${routeData.path.length} points, ${(routeData.distance / 1609.34).toFixed(2)} mi`);

                        const segmentStart = allRouteCoordinates.length;
                        allRouteCoordinates.push(...routeData.path);

                        segmentData.push({
                            start: segmentStart,
                            end: allRouteCoordinates.length - 1,
                            distance: routeData.distance,
                            midpoint: routeData.path[Math.floor(routeData.path.length / 2)]
                        });

                        totalDistance += routeData.distance;
                        totalDuration += routeData.duration;
                        successfulRoutes++;
                    } else {
                        // Fallback to straight line if routing fails
                        console.warn(`✗ Route ${i + 1} failed, using straight line`);
                        allRouteCoordinates.push([start.lat, start.lon], [end.lat, end.lon]);
                    }
                }

                console.log(`Route fetching complete: ${successfulRoutes}/${tourRoute.length - 1} successful`);
                console.log(`Total coordinates: ${allRouteCoordinates.length}`);

                // Store the full route coordinates globally for progressive tracking
                window.fullRouteCoordinates = allRouteCoordinates;
                window.completedRouteCoordinates = [];

                // Draw the complete walking route as a dashed line (preview mode)
                if (tourPath) map.removeLayer(tourPath);
                tourPath = L.polyline(allRouteCoordinates, {
                    color: '#4f46e5',
                    weight: 4,
                    opacity: 0.7,
                    dashArray: '10, 5'
                }).addTo(map);

                // Initialize completed path layer (will be updated as user moves)
                if (window.completedPath) map.removeLayer(window.completedPath);
                window.completedPath = null;

                // Initialize distance markers array
                if (!window.distanceMarkers) window.distanceMarkers = [];

                // Add distance labels for each segment
                segmentData.forEach((segment, index) => {
                    const distanceMiles = (segment.distance / 1609.34).toFixed(1);
                    const midpoint = segment.midpoint;

                    if (midpoint) {
                        const marker = L.marker([midpoint[0], midpoint[1]], {
                            icon: L.divIcon({
                                className: 'distance-label',
                                html: `<div style="background: white; padding: 4px 8px; border-radius: 12px; border: 2px solid #7c3aed; font-size: 11px; font-weight: bold; color: #7c3aed; white-space: nowrap; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">${distanceMiles} mi</div>`,
                                iconSize: [60, 24]
                            })
                        }).addTo(map);
                        window.distanceMarkers.push(marker);
                    }
                });

                // Display total distance and duration in navigation panel
                // Walking speed: 2.5 mph = 0.04167 miles per minute = 24 minutes per mile
                const distanceMiles = (totalDistance / 1609.34).toFixed(1);
                const durationMinutes = Math.round((totalDistance / 1609.34) * 24); // 24 min per mile at 2.5mph

                document.getElementById('tourDistance').textContent = `${distanceMiles} mi`;
                document.getElementById('tourDuration').textContent = `~${durationMinutes} min`;
                document.getElementById('tourStats').classList.remove('hidden');

                // Hide loading overlay
                loadingOverlay.classList.add('hidden');

                document.getElementById('navigationPanel').classList.remove('translate-y-full', 'opacity-0');

                // CHANGE BUTTON TO STOP TOUR
                const tourBtn = document.getElementById('startTourButton');
                tourBtn.textContent = "Stop Tour";
                tourBtn.classList.remove('bg-emerald-500', 'hover:bg-emerald-600');
                tourBtn.classList.add('bg-red-500', 'hover:bg-red-600');
                tourBtn.onclick = endTour;

                updateNavigationPanel();
                map.fitBounds(tourPath.getBounds(), { padding: [50, 50] });
            } catch (e) {
                console.error("Create Custom Tour Error:", e);
                document.getElementById('loadingOverlay').classList.add('hidden');
                showMessage("Tour Error", "Failed to create custom tour: " + e.message);
            }
        };


        const fetchWikipediaLandmarks = async (lat, lon, keyword) => {
            if (isFetching) return;
            isFetching = true;
            landmarkMarkers.clearLayers();
            tourPoints = [];

            // Use the fixed radius (5km) for the API call
            const radiusMeters = FIXED_SEARCH_RADIUS_KM * 1000;

            let url = `${WIKIPEDIA_API_URL}?action=query&list=geosearch&gsradius=${radiusMeters}&gscoord=${lat}|${lon}&gslimit=50&format=json&origin=*`;

            try {
                const data = await fetchWithRetry(url);
                const pages = data.query?.geosearch || [];

                // Optional keyword filtering (applied client-side)
                const filteredPages = keyword
                    ? pages.filter(p => p.title.toLowerCase().includes(keyword.toLowerCase()))
                    : pages;

                filteredPages.forEach(p => {
                    pinLandmark(p.lat, p.lon, p.title, `https://en.wikipedia.org/?curid=${p.pageid}`);
                });

                isFetching = false;
                document.getElementById('tourStatus').textContent = `Found ${filteredPages.length} landmarks.`;

            } catch (error) {
                console.error("Wikipedia GeoSearch Error:", error);
                showMessage("Data Error", "Could not fetch landmark data from Wikipedia.");
                isFetching = false;
            }
        };

        const pinLandmark = (lat, lon, title, url) => {
            const marker = L.marker([lat, lon], { icon: landmarkIcon }).addTo(landmarkMarkers);
            const popupContent = `
                <div class="font-bold text-indigo-700">${title}</div>
                <div class="text-sm mt-1">
                    <a href="${url}" target="_blank" class="text-indigo-500 hover:text-indigo-700 underline">Read on Wikipedia</a>
                </div>
            `;
            marker.bindPopup(popupContent);
            tourPoints.push({ lat, lon, title, isWiki: true, url, marker });
        };

        const fetchAndPinLandmarks = () => {
            const center = map.getCenter();
            // Pass the fixed radius implicitly
            const keyword = document.getElementById('categoryFilter').value.trim();
            fetchWikipediaLandmarks(center.lat, center.lng, keyword);
        };


        // Wrapper function to handle async createTour
        const handleCreateTour = async () => {
            console.log("handleCreateTour called");
            closeTourPanel();
            await createTour(true);
        };

        const createTour = async (reset = false) => {
            console.log("createTour function started");
            const maxDistanceMiles = parseFloat(document.getElementById('tourDistance').value);
            const maxDistanceMeters = maxDistanceMiles * 1609.34;

            if (tourPoints.length < 2) {
                document.getElementById('tourStatus').textContent = 'Error: Not enough landmarks loaded.';
                showMessage("Tour Failed: No Pins", `Only ${tourPoints.length} landmarks found on the map. Please ensure the map is centered over a major city.`);
                return;
            }

            const refLatLong = userMarker ? userMarker.getLatLng() : map.getCenter();

            const startPoint = {
                lat: refLatLong.lat,
                lon: refLatLong.lng,
                title: userMarker ? "Your Start Location" : "Map Center Start",
                isWiki: false,
                url: null
            };

            let potentialStops = tourPoints.filter(p => {
                const distance = getDistance(startPoint.lat, startPoint.lon, p.lat, p.lon);
                return distance <= maxDistanceMeters;
            }).map(p => ({
                ...p,
                distance: getDistance(startPoint.lat, startPoint.lon, p.lat, p.lon)
            }));

            if (potentialStops.length < 2) {
                document.getElementById('tourStatus').textContent = `Error: Only ${potentialStops.length} pins available locally.`;
                showMessage("Tour Failed: Pins Too Far", `Only ${potentialStops.length} landmarks found within ${maxDistanceMiles} miles of the starting point. Try increasing the Max Tour Distance in this panel.`);
                return;
            }

            potentialStops.sort((a, b) => a.distance - b.distance);

            // Create the route: Start -> Closest Stops -> Return to Start
            const returnToStart = { ...startPoint, title: "Return to Start" };
            tourRoute = [startPoint, ...potentialStops.slice(0, 5), returnToStart];
            currentTourStep = 0;
            currentManeuverIndex = -1;

            try {
                // Show loading message
                document.getElementById('tourStatus').textContent = 'Calculating walking routes...';

                // Fetch actual walking routes for all segments
                const allRouteCoordinates = [];
                let totalDistance = 0;
                let totalDuration = 0;
                let successfulRoutes = 0;

                console.log(`Fetching routes for ${tourRoute.length - 1} segments...`);

                for (let i = 0; i < tourRoute.length - 1; i++) {
                    const start = tourRoute[i];
                    const end = tourRoute[i + 1];

                    console.log(`Fetching route ${i + 1}/${tourRoute.length - 1}: ${start.title} -> ${end.title}`);
                    const routeData = await fetchWalkingRoute(start.lat, start.lon, end.lat, end.lon);

                    if (routeData && routeData.path && routeData.path.length > 0) {
                        // Add the route coordinates
                        console.log(`✓ Route ${i + 1} fetched: ${routeData.path.length} points, ${(routeData.distance / 1609.34).toFixed(2)} mi`);
                        allRouteCoordinates.push(...routeData.path);
                        totalDistance += routeData.distance;
                        totalDuration += routeData.duration;
                        successfulRoutes++;
                    } else {
                        // Fallback to straight line if routing fails
                        console.warn(`✗ Route ${i + 1} failed, using straight line`);
                        allRouteCoordinates.push([start.lat, start.lon], [end.lat, end.lon]);
                    }
                }

                console.log(`Route fetching complete: ${successfulRoutes}/${tourRoute.length - 1} successful`);
                console.log(`Total coordinates: ${allRouteCoordinates.length}`);

                // Store the full route coordinates globally for progressive tracking
                window.fullRouteCoordinates = allRouteCoordinates;
                window.completedRouteCoordinates = [];

                // Draw the complete walking route as a dashed line (preview mode)
                if (tourPath) map.removeLayer(tourPath);
                tourPath = L.polyline(allRouteCoordinates, {
                    color: '#7c3aed',  // Purple color
                    weight: 4,
                    opacity: 0.7,
                    dashArray: '10, 10'
                }).addTo(map);

                // Initialize completed path layer (will be updated as user moves)
                if (window.completedPath) map.removeLayer(window.completedPath);
                window.completedPath = null;

                // Display total distance and duration in navigation panel
                // Walking speed: 2.5 mph = 24 minutes per mile
                const distanceMiles = (totalDistance / 1609.34).toFixed(1);
                const durationMinutes = Math.round((totalDistance / 1609.34) * 24); // 24 min per mile at 2.5mph

                document.getElementById('tourDistance').textContent = `${distanceMiles} mi`;
                document.getElementById('tourDuration').textContent = `~${durationMinutes} min`;
                document.getElementById('tourStats').classList.remove('hidden');

                document.getElementById('navigationPanel').classList.remove('translate-y-full', 'opacity-0');

                // CHANGE BUTTON TO STOP TOUR
                const tourBtn = document.getElementById('startTourButton');
                tourBtn.textContent = "Stop Tour";
                tourBtn.classList.remove('bg-emerald-500', 'hover:bg-emerald-600');
                tourBtn.classList.add('bg-red-500', 'hover:bg-red-600');
                tourBtn.onclick = endTour;

                updateNavigationPanel();
                map.fitBounds(tourPath.getBounds(), { padding: [50, 50] });
            } catch (e) {
                console.error("Create Tour Error:", e);
                showMessage("Tour Error", "Failed to create tour: " + e.message);
            }
        };


        /**
         * Fetches the detailed walking route to the current destination and updates the map.
         */
        const initiateRoute = async () => {
            if (currentTourStep <= 0 || currentTourStep >= tourRoute.length) return;

            const endPoint = tourRoute[currentTourStep]; // Target

            const userLatLong = userMarker ? userMarker.getLatLng() : map.getCenter();

            // Use current user location as the actual start of the segment
            const currentStart = { lat: userLatLong.lat, lon: userLatLong.lng };

            document.getElementById('navActionButton').textContent = "Calculating Route...";
            document.getElementById('navActionButton').disabled = true;

            const routeData = await fetchWalkingRoute(currentStart.lat, currentStart.lon, endPoint.lat, endPoint.lon);

            // Clear old path
            if (tourPath) map.removeLayer(tourPath);

            if (routeData) {
                // Store the steps in the target object
                tourRoute[currentTourStep].steps = routeData.steps;
                currentManeuverIndex = 0; // Reset maneuver tracking

                // Draw the detailed OSRM route
                tourPath = L.polyline(routeData.path, {
                    color: '#7c3aed',  // Purple to match preview
                    weight: 6,
                    opacity: 0.9,
                    lineJoin: 'round'
                }).addTo(map);

                // Estimate time and distance
                const distanceKm = (routeData.distance / 1000).toFixed(2);
                const durationMinutes = Math.ceil(routeData.duration / 60);

                // Update the instruction with overall segment data
                let nextText = `Walk ${distanceKm} km (approx. ${durationMinutes} min). <br>`;
                if (endPoint.isWiki) {
                    nextText += `Destination: <span class="font-bold">${endPoint.title}</span>. <a href="${endPoint.url}" target="_blank" class="text-white underline hover:text-green-200">(Wiki Info)</a>`;
                } else {
                    nextText += `Destination: <span class="font-bold">${endPoint.title}</span>.`;
                }

                document.getElementById('nextLandmarkInfo').innerHTML = nextText;

                // Set high zoom level for GPS mode
                map.setView(userLatLong, 18, { animate: true, duration: 1.5 });
            } else {
                // Fallback: draw a simple line
                const simplePath = [
                    L.latLng(currentStart.lat, currentStart.lon),
                    L.latLng(endPoint.lat, endPoint.lon)
                ];
                tourPath = L.polyline(simplePath, {
                    color: '#f87171',
                    weight: 4,
                    opacity: 0.7
                }).addTo(map);

                document.getElementById('nextLandmarkInfo').innerHTML = `
                    Routing failed, follow the straight line to: 
                    <span class="font-bold">${endPoint.title}</span>.
                `;
                map.setView(userLatLong, 18, { animate: true, duration: 1.5 });
            }

            document.getElementById('navActionButton').textContent = "Next Stop";
            document.getElementById('navActionButton').disabled = true;
        }

        const updateNavigationPanel = () => {
            if (!tourRoute || tourRoute.length <= 1) return;

            const totalStops = tourRoute.length - 1;
            document.getElementById('navStepCounter').textContent = `${currentTourStep}/${totalStops}`;

            if (currentTourStep === 0) {
                // Pre-Navigation State
                const nextStop = tourRoute[1];
                document.getElementById('currentNavInstruction').textContent = "Tour Ready: Conceptual Route";
                document.getElementById('nextLandmarkInfo').innerHTML = `The dashed line shows the approximate path. Press <span class="font-bold">'Start Navigation'</span> to get the walking route to: <span class="font-bold">${nextStop.title}</span>.`;
                document.getElementById('navActionButton').textContent = "Start Navigation";
                document.getElementById('navActionButton').disabled = false;

            } else if (currentTourStep < tourRoute.length) {
                // Mid-tour steps - Trigger detailed route fetch
                const target = tourRoute[currentTourStep];
                document.getElementById('currentNavInstruction').textContent = `Navigating to Stop ${currentTourStep}/${totalStops}: ${target.title}`;

                // Only initiate route if steps haven't been loaded yet for this segment
                if (!target.steps) {
                    initiateRoute();
                }

            } else {
                // Tour finished
                document.getElementById('currentNavInstruction').textContent = "Tour Completed!";
                document.getElementById('nextLandmarkInfo').textContent = "You've visited all designated historic points!";
                document.getElementById('navActionButton').textContent = "End Tour";
                document.getElementById('navActionButton').disabled = false;
            }
        }

        const nextSegment = () => {
            if (currentTourStep < tourRoute.length - 1) {
                // Advance to the next landmark
                currentTourStep++;
                // Reset maneuver index for the new segment
                currentManeuverIndex = 0;
                updateNavigationPanel();
            } else if (currentTourStep === 0) {
                // Initial click on "Start Navigation"
                currentTourStep = 1;
                updateNavigationPanel(); // This triggers initiateRoute()
            }
            else if (currentTourStep === tourRoute.length - 1) {
                endTour();
            }
        }

        const endTour = () => {
            // End Tour logic - remove all route layers
            if (tourPath) map.removeLayer(tourPath);
            if (window.completedPath) map.removeLayer(window.completedPath);

            // Remove all distance label markers
            if (window.distanceMarkers && window.distanceMarkers.length > 0) {
                window.distanceMarkers.forEach(marker => map.removeLayer(marker));
                window.distanceMarkers = [];
            }

            tourRoute = null;
            currentTourStep = 0;
            currentManeuverIndex = -1;
            window.fullRouteCoordinates = [];
            window.completedRouteCoordinates = [];

            document.getElementById('navigationPanel').classList.add('translate-y-full', 'opacity-0');
            document.getElementById('tourStats').classList.add('hidden');

            // RESET BUTTON TO START TOUR
            const tourBtn = document.getElementById('startTourButton');
            tourBtn.textContent = "Start Tour";
            tourBtn.classList.remove('bg-red-500', 'hover:bg-red-600');
            tourBtn.classList.add('bg-emerald-500', 'hover:bg-emerald-600');
            tourBtn.onclick = openTourPanel;
        }

        const checkTourProgress = (userLatLong) => {
            // Only perform GPS checks if we are actively navigating to a landmark
            if (!tourRoute || currentTourStep < 1 || currentTourStep >= tourRoute.length || !tourRoute[currentTourStep].steps) {
                if (currentTourStep > 0 && userMarker) {
                    // Pan map to keep user in center during navigation
                    map.panTo(userMarker.getLatLng(), { animate: true, duration: 1.0 });
                }
                return;
            }

            const target = tourRoute[currentTourStep];
            const userLat = userLatLong[0];
            const userLon = userLatLong[1];

            const distanceToDestination = getDistance(userLat, userLon, target.lat, target.lon);
            const arrivalThreshold = 50; // 50 meters

            // --- 1. Check for Destination Arrival ---
            if (distanceToDestination < arrivalThreshold) {
                document.getElementById('navActionButton').disabled = false;
                document.getElementById('currentNavInstruction').innerHTML = `<span class="text-yellow-200 font-bold">ARRIVED:</span> ${target.title}`;
                document.getElementById('nextLandmarkInfo').textContent = `You have reached this location. Press 'Next Stop' to continue the tour.`;
                return;
            }

            // --- 2. Get Next Maneuver Instruction ---
            const maneuverResult = findNextManeuver(userLat, userLon, target.steps);

            // Update the Panel with GPS Instructions
            if (!maneuverResult.finished) {
                const distanceMeters = maneuverResult.distance.toFixed(0);

                document.getElementById('currentNavInstruction').innerHTML = `
                    <span class="font-bold">${maneuverResult.instruction}</span>
                `;

                document.getElementById('nextLandmarkInfo').innerHTML = `
                    Distance to turn: <span class="font-bold">${distanceMeters} meters</span>.
                    <br>
                    Heading to <span class="font-bold">${target.title}</span>.
                `;

                // If the user has progressed past the last known maneuver, update the index.
                if (maneuverResult.index > currentManeuverIndex) {
                    currentManeuverIndex = maneuverResult.index;
                }
            } else {
                // Final stretch before arrival
                const distanceMeters = distanceToDestination.toFixed(0);
                document.getElementById('currentNavInstruction').innerHTML = `Final Stretch: Proceed to ${target.title}`;
                document.getElementById('nextLandmarkInfo').textContent = `Distance remaining: ${distanceMeters} meters.`;
            }

            // --- 3. Keep User Centered and Zoomed ---
            map.panTo(userMarker.getLatLng(), { animate: true, duration: 1.0 });
            if (map.getZoom() < 18) map.setZoom(18);
        }

        document.addEventListener('DOMContentLoaded', initMap);
    </script>
</body>

</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Historic Landmark Explorer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20n6c65A8dD2EaX6dG8BfFz2u6G2YkR/x3+t6M9A5E0="
        crossorigin=""></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN8cPDZZAqP1CvWdoU2A5q+TjF+YJpwa8="
        crossorigin=""/>
    <style>
        /* Custom font */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fc;
        }
        #map {
            height: 100vh;
            width: 100vw;
            z-index: 10; /* Below the header and card */
        }
        .leaflet-container {
            font-family: 'Inter', sans-serif;
        }
    </style>
</head>
<body class="flex flex-col h-screen overflow-hidden">

    <!-- Header -->
    <header class="bg-indigo-600 shadow-xl z-50 p-4">
        <h1 class="text-2xl font-bold text-white">Historic Places Explorer</h1>
        <p class="text-indigo-200 text-sm">Real data from the National Register of Historic Places</p>
    </header>

    <!-- Map Container -->
    <div id="map" class="flex-grow"></div>

    <!-- Landmark Details Card (Modal-style) -->
    <div id="detailsCard" class="fixed inset-0 bg-gray-900 bg-opacity-75 z-40 hidden flex items-center justify-center p-4" onclick="closeCard()">
        <div class="bg-white rounded-xl shadow-2xl w-full max-w-md md:max-w-lg lg:max-w-2xl overflow-hidden transform transition-all duration-300 scale-100" onclick="event.stopPropagation()">
            <!-- Card Header -->
            <div class="p-5 border-b border-gray-100 flex justify-between items-start bg-indigo-50">
                <h2 id="cardTitle" class="text-xl md:text-2xl font-extrabold text-gray-800">Landmark Details</h2>
                <button onclick="closeCard()" class="text-gray-400 hover:text-gray-600 transition">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            
            <!-- Card Body -->
            <div class="p-5 max-h-[70vh] overflow-y-auto">
                <div id="cardContent" class="text-gray-700 space-y-4">
                    <!-- Dynamic content will be loaded here -->
                    <div id="summarySection">
                        <h3 class="text-lg font-semibold text-indigo-700 mb-2">Historical Summary (Powered by Gemini)</h3>
                        <div id="summaryText" class="text-sm leading-relaxed">
                            <p class="italic text-gray-500">Loading historical details...</p>
                        </div>
                        <div id="sourcesContainer" class="mt-4 pt-4 border-t border-gray-100 hidden">
                             <p class="font-medium text-xs text-gray-500 mb-1">Sources:</p>
                             <ul id="sourcesList" class="list-disc pl-5 text-xs text-indigo-600 space-y-1"></ul>
                        </div>
                    </div>

                    <div id="errorSection" class="hidden bg-red-50 p-3 rounded-lg border border-red-200">
                        <p class="text-sm text-red-700 font-medium">Error:</p>
                        <p id="errorText" class="text-xs text-red-600 mt-1"></p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Loading Spinner (for LLM call) -->
    <div id="loadingSpinner" class="fixed bottom-4 right-4 bg-indigo-700 text-white p-3 rounded-full shadow-lg z-50 flex items-center hidden">
        <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
        <span class="text-sm font-medium">Gathering history...</span>
    </div>

    <script type="module">
        // Import Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- GLOBAL CONFIG & INITIALIZATION ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        const apiKey = ""; // API key for Gemini

        let app, db, auth;
        let userId = null;
        let isAuthReady = false;

        // Landmark data from the National Register of Historic Places (NRHP)
        // A curated list of 10 iconic US landmarks with their actual coordinates.
        const landmarks = [
            { id: 'statue_liberty', name: 'Statue of Liberty', lat: 40.689249, lng: -74.044500, description: 'National Monument in New York Harbor.' },
            { id: 'golden_gate', name: 'Golden Gate Bridge', lat: 37.819929, lng: -122.478256, description: 'Iconic suspension bridge connecting San Francisco Bay and the Pacific Ocean.' },
            { id: 'alcatraz', name: 'Alcatraz Island', lat: 37.826978, lng: -122.422998, description: 'Famous former prison island in San Francisco Bay.' },
            { id: 'white_house', name: 'The White House', lat: 38.8977, lng: -77.0366, description: 'Official residence and workplace of the President of the United States.' },
            { id: 'lincoln_memorial', name: 'Lincoln Memorial', lat: 38.8892, lng: -77.0506, description: 'American national monument built to honor the 16th President of the United States, Abraham Lincoln.' },
            { id: 'independence_hall', name: 'Independence Hall', lat: 39.9488, lng: -75.1500, description: 'The site where both the Declaration of Independence and the Constitution were debated and adopted.' },
            { id: 'mound_city_group', name: 'Mound City Group National Historical Park', lat: 39.3783, lng: -83.0031, description: 'Preserves 23 burial mounds built by the Hopewell culture.' },
            { id: 'mesa_verde', name: 'Mesa Verde National Park', lat: 37.1822, lng: -108.4907, description: 'Preserves the rich cultural heritage of the Ancestral Pueblo people.' },
            { id: 'chaco_culture', name: 'Chaco Culture National Historical Park', lat: 36.0601, lng: -107.9542, description: 'A center of ancestral Pueblo culture.' },
            { id: 'pearl_harbor', name: 'Pearl Harbor National Memorial', lat: 21.3653, lng: -157.9478, description: 'Commemorates the 1941 attack on Pearl Harbor.' }
        ];

        // --- FIREBASE AUTHENTICATION & INITIALIZATION ---

        /**
         * Initializes Firebase app and services.
         */
        function initializeFirebase() {
            if (Object.keys(firebaseConfig).length > 0) {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                setLogLevel('debug'); // Enable Firestore logging

                // Set up Auth State Listener
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        console.log("Firebase Auth Ready. User ID:", userId);
                    } else {
                        // This handles the sign-in process if token is not available (which shouldn't happen in Canvas)
                        try {
                            if (initialAuthToken) {
                                await signInWithCustomToken(auth, initialAuthToken);
                            } else {
                                await signInAnonymously(auth);
                            }
                            userId = auth.currentUser.uid;
                        } catch (error) {
                            console.error("Firebase Sign-In Error:", error);
                            // Fallback to anonymous ID if sign-in fails
                            userId = crypto.randomUUID();
                        }
                    }
                    isAuthReady = true;
                    // Proceed with map and data loading once auth is confirmed
                    initMap();
                });
            } else {
                console.error("Firebase config is missing or invalid. Running without persistent storage.");
                // Fallback for environment without Firebase
                userId = crypto.randomUUID();
                isAuthReady = true;
                initMap();
            }
        }

        // --- FIRESTORE UTILITIES ---

        /**
         * Generates the path for a landmark's details (public data).
         * @param {string} landmarkId The ID of the landmark.
         * @returns {string} The full Firestore document path.
         */
        function getLandmarkDocPath(landmarkId) {
            // Public data path: /artifacts/{appId}/public/data/landmarks/{landmarkId}
            return `artifacts/${appId}/public/data/landmarks/${landmarkId}`;
        }

        // --- MAP AND UI FUNCTIONS ---

        let map = null;

        /**
         * Initializes the Leaflet map and adds markers for all landmarks.
         */
        function initMap() {
            if (map) return; // Prevent double initialization

            // Initialize map centered near the center of the US for a good overview
            map = L.map('map').setView([39.8283, -98.5795], 4);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            // Add markers for all historical landmarks
            landmarks.forEach(landmark => {
                const marker = L.marker([landmark.lat, landmark.lng]).addTo(map)
                    .bindPopup(
                        `<h4 class="font-bold text-indigo-700">${landmark.name}</h4>
                        <p class="text-xs">${landmark.description}</p>
                        <button class="mt-2 text-sm text-white bg-indigo-500 hover:bg-indigo-600 px-3 py-1 rounded-full shadow-md" 
                                onclick="openCard('${landmark.id}', '${landmark.name.replace(/'/g, "\\'")}')">
                            Explore History
                        </button>`
                    );
            });
        }

        /**
         * Opens the detail card and triggers data loading.
         * @param {string} id The unique ID of the landmark.
         * @param {string} name The name of the landmark.
         */
        window.openCard = async function(id, name) {
            const card = document.getElementById('detailsCard');
            const title = document.getElementById('cardTitle');
            const summaryText = document.getElementById('summaryText');
            const errorSection = document.getElementById('errorSection');
            const summarySection = document.getElementById('summarySection');
            const loadingSpinner = document.getElementById('loadingSpinner');

            // 1. Show Card and Set Title
            title.textContent = name;
            summaryText.innerHTML = '<p class="italic text-gray-500">Loading historical details...</p>';
            errorSection.classList.add('hidden');
            summarySection.classList.remove('hidden');
            card.classList.remove('hidden');
            
            // 2. Try to Load Cached Data from Firestore
            const cachedData = await getCachedDetails(id);
            if (cachedData) {
                console.log("Using cached data.");
                updateCardContent(cachedData.summary, cachedData.sources);
                return;
            }

            // 3. If no cache, fetch from Gemini
            console.log("No cache found. Fetching from Gemini...");
            loadingSpinner.classList.remove('hidden');
            
            try {
                await fetchLandmarkDetails(id, name);
            } catch (error) {
                console.error("Failed to fetch or process landmark details:", error);
                errorSection.classList.remove('hidden');
                document.getElementById('errorText').textContent = `Could not load historical summary due to a network or API error. (${error.message || 'Unknown error'})`;
                summarySection.classList.add('hidden');
            } finally {
                loadingSpinner.classList.add('hidden');
            }
        }

        /**
         * Closes the detail card.
         */
        window.closeCard = function() {
            document.getElementById('detailsCard').classList.add('hidden');
            // Reset content
            document.getElementById('summaryText').innerHTML = '<p class="italic text-gray-500">Loading historical details...</p>';
            document.getElementById('sourcesContainer').classList.add('hidden');
        }

        /**
         * Updates the card with the fetched or cached content.
         * @param {string} summary The historical summary text.
         * @param {Array<{uri: string, title: string}>} sources Array of citation sources.
         */
        function updateCardContent(summary, sources) {
            const summaryText = document.getElementById('summaryText');
            const sourcesContainer = document.getElementById('sourcesContainer');
            const sourcesList = document.getElementById('sourcesList');

            // Format text (simple Markdown to HTML conversion)
            let formattedSummary = summary.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            formattedSummary = formattedSummary.replace(/\n\n/g, '</p><p>');
            formattedSummary = `<p>${formattedSummary}</p>`;
            summaryText.innerHTML = formattedSummary;

            // Handle sources
            sourcesList.innerHTML = '';
            if (sources && sources.length > 0) {
                sources.forEach(source => {
                    const li = document.createElement('li');
                    li.innerHTML = `<a href="${source.uri}" target="_blank" class="hover:underline">${source.title || source.uri}</a>`;
                    sourcesList.appendChild(li);
                });
                sourcesContainer.classList.remove('hidden');
            } else {
                sourcesContainer.classList.add('hidden');
            }
        }

        // --- GEMINI API CALL & CACHING LOGIC ---

        /**
         * Fetches cached landmark details from Firestore.
         * @param {string} id The unique ID of the landmark.
         * @returns {Promise<{summary: string, sources: Array} | null>} Cached data or null.
         */
        async function getCachedDetails(id) {
            if (!isAuthReady || !db) return null;

            const docPath = getLandmarkDocPath(id);
            try {
                const docRef = doc(db, docPath);
                const docSnap = await getDoc(docRef);
                
                if (docSnap.exists()) {
                    return docSnap.data();
                }
            } catch (error) {
                console.warn("Error reading cache from Firestore, proceeding to fetch:", error);
            }
            return null;
        }

        /**
         * Caches the generated summary and sources to Firestore.
         * @param {string} id The unique ID of the landmark.
         * @param {string} summary The generated summary text.
         * @param {Array} sources The citation sources.
         */
        async function cacheDetails(id, summary, sources) {
            if (!isAuthReady || !db) return;

            const docPath = getLandmarkDocPath(id);
            try {
                // Using setDoc with merge: true for simplicity, ensuring we don't overwrite other fields if they existed.
                await setDoc(doc(db, docPath), {
                    summary: summary,
                    sources: sources,
                    cachedAt: new Date().toISOString()
                }, { merge: true });
                console.log("Landmark details cached successfully.");
            } catch (error) {
                console.error("Error writing cache to Firestore:", error);
            }
        }

        /**
         * Calls the Gemini API to get historical details for a landmark with exponential backoff.
         * @param {string} id The landmark ID for caching.
         * @param {string} name The landmark name for the prompt.
         */
        async function fetchLandmarkDetails(id, name) {
            const systemPrompt = "You are a concise, world-class historian. Your task is to provide a single, detailed paragraph (maximum 150 words) summarizing the key historical significance, construction date, and major events associated with the requested landmark. Use formal, engaging language. Do not use bullet points or lists. Do not include a title or introduction.";
            const userQuery = `Summarize the history and significance of the ${name}.`;
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                tools: [{ "google_search": {} }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
            };

            const maxRetries = 5;
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        if (response.status === 429 && i < maxRetries - 1) {
                            const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
                            console.warn(`Rate limit hit. Retrying in ${Math.round(delay/1000)}s...`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                            continue; // Retry the request
                        }
                        throw new Error(`API request failed with status: ${response.statusText}`);
                    }

                    const result = await response.json();
                    const candidate = result.candidates?.[0];

                    if (candidate && candidate.content?.parts?.[0]?.text) {
                        const summary = candidate.content.parts[0].text;
                        let sources = [];
                        
                        const groundingMetadata = candidate.groundingMetadata;
                        if (groundingMetadata && groundingMetadata.groundingAttributions) {
                            sources = groundingMetadata.groundingAttributions
                                .map(attribution => ({
                                    uri: attribution.web?.uri,
                                    title: attribution.web?.title,
                                }))
                                .filter(source => source.uri);
                        }

                        // Update UI and Cache the result
                        updateCardContent(summary, sources);
                        await cacheDetails(id, summary, sources);
                        return;

                    } else {
                        throw new Error("API returned an invalid or empty response structure.");
                    }

                } catch (error) {
                    if (i === maxRetries - 1) {
                        // Throw the error if all retries fail
                        throw new Error(`Failed to fetch landmark details after ${maxRetries} attempts: ${error.message}`);
                    }
                    // Continue to the next retry loop
                }
            }
        }
        
        // --- START APPLICATION ---
        document.addEventListener('DOMContentLoaded', initializeFirebase);
    </script>
</body>
</html>
